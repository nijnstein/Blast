//###########################################################################################################################
// BLAST v1.0.4c - Copyright Â© 2022 Rob Lemmens | NijnStein Software <rob.lemmens.s31 gmail com> All Rights Reserved   ^__^\#
// Unauthorized copying of this file, via any medium is strictly prohibited proprietary and confidential               (oo)\#
//                                                                                                                     (__) #
//###########################################################################################################################


// *** This file has been generated by BLAST: modification is futile an will be assimilated ***

#if STANDALONE_VSBUILD
    using NSS.Blast.Standalone;
    using System.Reflection;
#else
    using UnityEngine;
    using Unity.Burst.CompilerServices;
#endif


using Unity.Burst;
using Unity.Mathematics;
using System.Runtime.CompilerServices;

                                    
using V1 = System.Single;
using V2 = Unity.Mathematics.float2;
using V3 = Unity.Mathematics.float3;
using V4 = Unity.Mathematics.float4;


namespace NSS.Blast.Interpretor
{
    unsafe public partial struct BlastInterpretor
    {


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_POW(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x       = math.pow(((float*)fdata)[0], pop_as_f1(ref code_pointer)); break;
                case BlastVectorType.float2: v4.xy      = math.pow(((float2*)fdata)[0], pop_as_f2(ref code_pointer)); break;
                case BlastVectorType.float3: v4.xyz     = math.pow(((float3*)fdata)[0], pop_as_f3(ref code_pointer)); break;
                case BlastVectorType.float4: v4         = math.pow(((float4*)fdata)[0], pop_as_f4(ref code_pointer)); break;

                case BlastVectorType.int1: v4.x         = math.pow(((int*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int2: v4.xy        = math.pow(((int2*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int3: v4.xyz       = math.pow(((int3*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int4: v4           = math.pow(((int4*)fdata)[0], pop_as_i1(ref code_pointer)); break;

                case BlastVectorType.float1_n: v4.x     = math.pow(-((float*)fdata)[0], pop_as_f1(ref code_pointer)); break;
                case BlastVectorType.float2_n: v4.xy    = math.pow(-((float2*)fdata)[0], pop_as_f2(ref code_pointer)); break;
                case BlastVectorType.float3_n: v4.xyz   = math.pow(-((float3*)fdata)[0], pop_as_f3(ref code_pointer)); break;
                case BlastVectorType.float4_n: v4       = math.pow(-((float4*)fdata)[0], pop_as_f4(ref code_pointer)); break;

                case BlastVectorType.int1_n: v4.x       = math.pow(-((int*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int2_n: v4.xy      = math.pow(-((int2*)fdata)[0], pop_as_i2(ref code_pointer)); break;
                case BlastVectorType.int3_n: v4.xyz     = math.pow(-((int3*)fdata)[0], pop_as_i3(ref code_pointer)); break;
                case BlastVectorType.int4_n: v4         = math.pow(-((int4*)fdata)[0], pop_as_i4(ref code_pointer)); break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.POW: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_FMOD(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x       = math.fmod(((float*)fdata)[0], pop_as_f1(ref code_pointer)); break;
                case BlastVectorType.float2: v4.xy      = math.fmod(((float2*)fdata)[0], pop_as_f2(ref code_pointer)); break;
                case BlastVectorType.float3: v4.xyz     = math.fmod(((float3*)fdata)[0], pop_as_f3(ref code_pointer)); break;
                case BlastVectorType.float4: v4         = math.fmod(((float4*)fdata)[0], pop_as_f4(ref code_pointer)); break;

                case BlastVectorType.int1: v4.x         = math.fmod(((int*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int2: v4.xy        = math.fmod(((int2*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int3: v4.xyz       = math.fmod(((int3*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int4: v4           = math.fmod(((int4*)fdata)[0], pop_as_i1(ref code_pointer)); break;

                case BlastVectorType.float1_n: v4.x     = math.fmod(-((float*)fdata)[0], pop_as_f1(ref code_pointer)); break;
                case BlastVectorType.float2_n: v4.xy    = math.fmod(-((float2*)fdata)[0], pop_as_f2(ref code_pointer)); break;
                case BlastVectorType.float3_n: v4.xyz   = math.fmod(-((float3*)fdata)[0], pop_as_f3(ref code_pointer)); break;
                case BlastVectorType.float4_n: v4       = math.fmod(-((float4*)fdata)[0], pop_as_f4(ref code_pointer)); break;

                case BlastVectorType.int1_n: v4.x       = math.fmod(-((int*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int2_n: v4.xy      = math.fmod(-((int2*)fdata)[0], pop_as_i2(ref code_pointer)); break;
                case BlastVectorType.int3_n: v4.xyz     = math.fmod(-((int3*)fdata)[0], pop_as_i3(ref code_pointer)); break;
                case BlastVectorType.int4_n: v4         = math.fmod(-((int4*)fdata)[0], pop_as_i4(ref code_pointer)); break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.FMOD: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_ATAN2(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x       = math.atan2(((float*)fdata)[0], pop_as_f1(ref code_pointer)); break;
                case BlastVectorType.float2: v4.xy      = math.atan2(((float2*)fdata)[0], pop_as_f2(ref code_pointer)); break;
                case BlastVectorType.float3: v4.xyz     = math.atan2(((float3*)fdata)[0], pop_as_f3(ref code_pointer)); break;
                case BlastVectorType.float4: v4         = math.atan2(((float4*)fdata)[0], pop_as_f4(ref code_pointer)); break;

                case BlastVectorType.int1: v4.x         = math.atan2(((int*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int2: v4.xy        = math.atan2(((int2*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int3: v4.xyz       = math.atan2(((int3*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int4: v4           = math.atan2(((int4*)fdata)[0], pop_as_i1(ref code_pointer)); break;

                case BlastVectorType.float1_n: v4.x     = math.atan2(-((float*)fdata)[0], pop_as_f1(ref code_pointer)); break;
                case BlastVectorType.float2_n: v4.xy    = math.atan2(-((float2*)fdata)[0], pop_as_f2(ref code_pointer)); break;
                case BlastVectorType.float3_n: v4.xyz   = math.atan2(-((float3*)fdata)[0], pop_as_f3(ref code_pointer)); break;
                case BlastVectorType.float4_n: v4       = math.atan2(-((float4*)fdata)[0], pop_as_f4(ref code_pointer)); break;

                case BlastVectorType.int1_n: v4.x       = math.atan2(-((int*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int2_n: v4.xy      = math.atan2(-((int2*)fdata)[0], pop_as_i2(ref code_pointer)); break;
                case BlastVectorType.int3_n: v4.xyz     = math.atan2(-((int3*)fdata)[0], pop_as_i3(ref code_pointer)); break;
                case BlastVectorType.int4_n: v4         = math.atan2(-((int4*)fdata)[0], pop_as_i4(ref code_pointer)); break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.ATAN2: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_DISTANCE(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x       = math.distance(((float*)fdata)[0], pop_as_f1(ref code_pointer)); break;
                case BlastVectorType.float2: v4.x      = math.distance(((float2*)fdata)[0], pop_as_f2(ref code_pointer)); break;
                case BlastVectorType.float3: v4.x     = math.distance(((float3*)fdata)[0], pop_as_f3(ref code_pointer)); break;
                case BlastVectorType.float4: v4.x         = math.distance(((float4*)fdata)[0], pop_as_f4(ref code_pointer)); break;

                case BlastVectorType.int1: v4.x         = math.distance(((int*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int2: v4.x        = math.distance(((int2*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int3: v4.x       = math.distance(((int3*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int4: v4.x           = math.distance(((int4*)fdata)[0], pop_as_i1(ref code_pointer)); break;

                case BlastVectorType.float1_n: v4.x     = math.distance(-((float*)fdata)[0], pop_as_f1(ref code_pointer)); break;
                case BlastVectorType.float2_n: v4.x    = math.distance(-((float2*)fdata)[0], pop_as_f2(ref code_pointer)); break;
                case BlastVectorType.float3_n: v4.x   = math.distance(-((float3*)fdata)[0], pop_as_f3(ref code_pointer)); break;
                case BlastVectorType.float4_n: v4.x       = math.distance(-((float4*)fdata)[0], pop_as_f4(ref code_pointer)); break;

                case BlastVectorType.int1_n: v4.x       = math.distance(-((int*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int2_n: v4.x      = math.distance(-((int2*)fdata)[0], pop_as_i2(ref code_pointer)); break;
                case BlastVectorType.int3_n: v4.x     = math.distance(-((int3*)fdata)[0], pop_as_i3(ref code_pointer)); break;
                case BlastVectorType.int4_n: v4.x         = math.distance(-((int4*)fdata)[0], pop_as_i4(ref code_pointer)); break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.DISTANCE: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
            vector_size = 1;            
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_DISTANCESQ(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x       = math.distancesq(((float*)fdata)[0], pop_as_f1(ref code_pointer)); break;
                case BlastVectorType.float2: v4.x      = math.distancesq(((float2*)fdata)[0], pop_as_f2(ref code_pointer)); break;
                case BlastVectorType.float3: v4.x     = math.distancesq(((float3*)fdata)[0], pop_as_f3(ref code_pointer)); break;
                case BlastVectorType.float4: v4.x         = math.distancesq(((float4*)fdata)[0], pop_as_f4(ref code_pointer)); break;

                case BlastVectorType.int1: v4.x         = math.distancesq(((int*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int2: v4.x        = math.distancesq(((int2*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int3: v4.x       = math.distancesq(((int3*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int4: v4.x           = math.distancesq(((int4*)fdata)[0], pop_as_i1(ref code_pointer)); break;

                case BlastVectorType.float1_n: v4.x     = math.distancesq(-((float*)fdata)[0], pop_as_f1(ref code_pointer)); break;
                case BlastVectorType.float2_n: v4.x    = math.distancesq(-((float2*)fdata)[0], pop_as_f2(ref code_pointer)); break;
                case BlastVectorType.float3_n: v4.x   = math.distancesq(-((float3*)fdata)[0], pop_as_f3(ref code_pointer)); break;
                case BlastVectorType.float4_n: v4.x       = math.distancesq(-((float4*)fdata)[0], pop_as_f4(ref code_pointer)); break;

                case BlastVectorType.int1_n: v4.x       = math.distancesq(-((int*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int2_n: v4.x      = math.distancesq(-((int2*)fdata)[0], pop_as_i2(ref code_pointer)); break;
                case BlastVectorType.int3_n: v4.x     = math.distancesq(-((int3*)fdata)[0], pop_as_i3(ref code_pointer)); break;
                case BlastVectorType.int4_n: v4.x         = math.distancesq(-((int4*)fdata)[0], pop_as_i4(ref code_pointer)); break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.DISTANCESQ: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
            vector_size = 1;            
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_REFLECT(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float2: v4.xy      = math.reflect(((float2*)fdata)[0], pop_as_f2(ref code_pointer)); break;
                case BlastVectorType.float3: v4.xyz     = math.reflect(((float3*)fdata)[0], pop_as_f3(ref code_pointer)); break;
                case BlastVectorType.float4: v4         = math.reflect(((float4*)fdata)[0], pop_as_f4(ref code_pointer)); break;

                case BlastVectorType.int2: v4.xy        = math.reflect(((int2*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int3: v4.xyz       = math.reflect(((int3*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int4: v4           = math.reflect(((int4*)fdata)[0], pop_as_i1(ref code_pointer)); break;

                case BlastVectorType.float2_n: v4.xy    = math.reflect(-((float2*)fdata)[0], pop_as_f2(ref code_pointer)); break;
                case BlastVectorType.float3_n: v4.xyz   = math.reflect(-((float3*)fdata)[0], pop_as_f3(ref code_pointer)); break;
                case BlastVectorType.float4_n: v4       = math.reflect(-((float4*)fdata)[0], pop_as_f4(ref code_pointer)); break;

                case BlastVectorType.int2_n: v4.xy      = math.reflect(-((int2*)fdata)[0], pop_as_i2(ref code_pointer)); break;
                case BlastVectorType.int3_n: v4.xyz     = math.reflect(-((int3*)fdata)[0], pop_as_i3(ref code_pointer)); break;
                case BlastVectorType.int4_n: v4         = math.reflect(-((int4*)fdata)[0], pop_as_i4(ref code_pointer)); break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.REFLECT: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_PROJECT(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float2: v4.xy      = math.project(((float2*)fdata)[0], pop_as_f2(ref code_pointer)); break;
                case BlastVectorType.float3: v4.xyz     = math.project(((float3*)fdata)[0], pop_as_f3(ref code_pointer)); break;
                case BlastVectorType.float4: v4         = math.project(((float4*)fdata)[0], pop_as_f4(ref code_pointer)); break;

                case BlastVectorType.int2: v4.xy        = math.project(((int2*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int3: v4.xyz       = math.project(((int3*)fdata)[0], pop_as_i1(ref code_pointer)); break;
                case BlastVectorType.int4: v4           = math.project(((int4*)fdata)[0], pop_as_i1(ref code_pointer)); break;

                case BlastVectorType.float2_n: v4.xy    = math.project(-((float2*)fdata)[0], pop_as_f2(ref code_pointer)); break;
                case BlastVectorType.float3_n: v4.xyz   = math.project(-((float3*)fdata)[0], pop_as_f3(ref code_pointer)); break;
                case BlastVectorType.float4_n: v4       = math.project(-((float4*)fdata)[0], pop_as_f4(ref code_pointer)); break;

                case BlastVectorType.int2_n: v4.xy      = math.project(-((int2*)fdata)[0], pop_as_i2(ref code_pointer)); break;
                case BlastVectorType.int3_n: v4.xyz     = math.project(-((int3*)fdata)[0], pop_as_i3(ref code_pointer)); break;
                case BlastVectorType.int4_n: v4         = math.project(-((int4*)fdata)[0], pop_as_i4(ref code_pointer)); break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.PROJECT: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }


    }
}

