//###########################################################################################################################
// BLAST v1.0.4c - Copyright Â© 2022 Rob Lemmens | NijnStein Software <rob.lemmens.s31 gmail com> All Rights Reserved   ^__^\#
// Unauthorized copying of this file, via any medium is strictly prohibited proprietary and confidential               (oo)\#
//                                                                                                                     (__) #
//###########################################################################################################################


// *** This file has been generated by BLAST: modification is futile an will be assimilated ***

#if STANDALONE_VSBUILD
    using NSS.Blast.Standalone;
    using System.Reflection;
#else
    using UnityEngine;
    using Unity.Burst.CompilerServices;
#endif


using Unity.Burst;
using Unity.Mathematics;
using System.Runtime.CompilerServices;

                                    
using V1 = System.Single;
using V2 = Unity.Mathematics.float2;
using V3 = Unity.Mathematics.float3;
using V4 = Unity.Mathematics.float4;


namespace NSS.Blast.Interpretor
{
    unsafe public partial struct BlastInterpretor
    {



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_ABS(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.abs(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.abs(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.abs(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.abs(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.abs(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.abs(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.abs(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.abs(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.abs(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.abs(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.abs(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.abs(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.abs(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.abs(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.abs(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.abs(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.ABS: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_TRUNC(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.trunc(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.trunc(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.trunc(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.trunc(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.trunc(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.trunc(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.trunc(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.trunc(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.trunc(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.trunc(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.trunc(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.trunc(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.trunc(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.trunc(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.trunc(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.trunc(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.TRUNC: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_EXP(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.exp(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.exp(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.exp(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.exp(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.exp(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.exp(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.exp(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.exp(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.exp(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.exp(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.exp(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.exp(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.exp(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.exp(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.exp(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.exp(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.EXP: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_EXP10(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.exp10(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.exp10(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.exp10(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.exp10(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.exp10(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.exp10(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.exp10(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.exp10(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.exp10(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.exp10(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.exp10(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.exp10(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.exp10(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.exp10(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.exp10(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.exp10(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.EXP10: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_LOG10(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.log10(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.log10(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.log10(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.log10(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.log10(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.log10(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.log10(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.log10(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.log10(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.log10(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.log10(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.log10(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.log10(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.log10(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.log10(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.log10(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.LOG10: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_LOGN(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.log(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.log(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.log(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.log(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.log(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.log(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.log(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.log(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.log(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.log(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.log(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.log(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.log(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.log(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.log(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.log(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.LOGN: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_LOG2(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.log2(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.log2(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.log2(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.log2(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.log2(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.log2(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.log2(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.log2(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.log2(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.log2(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.log2(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.log2(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.log2(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.log2(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.log2(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.log2(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.LOG2: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_SQRT(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.sqrt(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.sqrt(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.sqrt(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.sqrt(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.sqrt(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.sqrt(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.sqrt(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.sqrt(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.sqrt(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.sqrt(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.sqrt(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.sqrt(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.sqrt(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.sqrt(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.sqrt(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.sqrt(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.SQRT: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_RSQRT(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.rsqrt(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.rsqrt(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.rsqrt(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.rsqrt(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.rsqrt(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.rsqrt(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.rsqrt(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.rsqrt(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.rsqrt(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.rsqrt(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.rsqrt(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.rsqrt(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.rsqrt(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.rsqrt(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.rsqrt(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.rsqrt(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.RSQRT: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_SIN(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.sin(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.sin(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.sin(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.sin(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.sin(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.sin(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.sin(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.sin(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.sin(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.sin(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.sin(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.sin(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.sin(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.sin(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.sin(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.sin(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.SIN: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_COS(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.cos(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.cos(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.cos(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.cos(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.cos(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.cos(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.cos(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.cos(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.cos(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.cos(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.cos(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.cos(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.cos(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.cos(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.cos(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.cos(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.COS: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_TAN(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.tan(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.tan(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.tan(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.tan(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.tan(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.tan(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.tan(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.tan(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.tan(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.tan(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.tan(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.tan(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.tan(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.tan(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.tan(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.tan(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.TAN: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_ATAN(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.atan(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.atan(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.atan(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.atan(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.atan(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.atan(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.atan(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.atan(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.atan(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.atan(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.atan(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.atan(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.atan(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.atan(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.atan(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.atan(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.ATAN: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_SINH(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.sinh(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.sinh(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.sinh(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.sinh(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.sinh(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.sinh(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.sinh(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.sinh(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.sinh(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.sinh(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.sinh(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.sinh(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.sinh(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.sinh(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.sinh(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.sinh(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.SINH: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_COSH(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.cosh(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.cosh(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.cosh(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.cosh(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.cosh(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.cosh(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.cosh(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.cosh(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.cosh(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.cosh(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.cosh(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.cosh(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.cosh(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.cosh(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.cosh(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.cosh(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.COSH: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_DEGREES(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.degrees(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.degrees(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.degrees(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.degrees(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.degrees(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.degrees(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.degrees(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.degrees(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.degrees(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.degrees(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.degrees(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.degrees(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.degrees(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.degrees(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.degrees(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.degrees(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.DEGREES: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_RADIANS(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.radians(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.radians(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.radians(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.radians(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.radians(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.radians(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.radians(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.radians(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.radians(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.radians(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.radians(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.radians(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.radians(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.radians(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.radians(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.radians(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.RADIANS: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_SATURATE(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.saturate(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.saturate(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.saturate(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.saturate(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.saturate(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.saturate(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.saturate(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.saturate(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.saturate(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.saturate(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.saturate(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.saturate(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.saturate(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.saturate(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.saturate(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.saturate(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.SATURATE: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_NORMALIZE(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            bool negated;
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float2: v4.xy    =  math.normalize(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.normalize(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.normalize(((float4*)fdata)[0]); break;

                case BlastVectorType.int2: v4.xy      =  math.normalize(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.normalize(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.normalize(((int4*)fdata)[0]);   break;

                case BlastVectorType.float2_n: v4.xy  = math.normalize(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.normalize(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.normalize(-((float4*)fdata)[0]); break;

                case BlastVectorType.int2_n: v4.xy    = math.normalize(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.normalize(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.normalize(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.NORMALIZE: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_CEIL(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.ceil(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.ceil(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.ceil(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.ceil(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.ceil(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.ceil(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.ceil(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.ceil(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.ceil(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.ceil(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.ceil(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.ceil(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.ceil(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.ceil(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.ceil(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.ceil(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.CEIL: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_FLOOR(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.floor(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.floor(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.floor(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.floor(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.floor(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.floor(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.floor(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.floor(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.floor(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.floor(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.floor(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.floor(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.floor(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.floor(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.floor(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.floor(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.FLOOR: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_FRAC(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.frac(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.frac(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.frac(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.frac(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.frac(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.frac(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.frac(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.frac(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.frac(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.frac(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.frac(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.frac(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.frac(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.frac(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.frac(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.frac(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.FRAC: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_CEILLOG2(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {
                case BlastVectorType.int1: v4.x       =  math.ceillog2(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.ceillog2(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.ceillog2(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.ceillog2(((int4*)fdata)[0]);   break;

                case BlastVectorType.int1_n: v4.x     = math.ceillog2(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.ceillog2(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.ceillog2(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.ceillog2(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.CEILLOG2: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_CEILPOW2(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {
                case BlastVectorType.int1: v4.x       =  math.ceilpow2(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.ceilpow2(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.ceilpow2(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.ceilpow2(((int4*)fdata)[0]);   break;

                case BlastVectorType.int1_n: v4.x     = math.ceilpow2(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.ceilpow2(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.ceilpow2(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.ceilpow2(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.CEILPOW2: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_FLOORLOG2(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {
                case BlastVectorType.int1: v4.x       =  math.floorlog2(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.floorlog2(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.floorlog2(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.floorlog2(((int4*)fdata)[0]);   break;

                case BlastVectorType.int1_n: v4.x     = math.floorlog2(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.floorlog2(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.floorlog2(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.floorlog2(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.FLOORLOG2: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_SIGN(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.sign(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  math.sign(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  math.sign(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  math.sign(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.sign(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  math.sign(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  math.sign(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  math.sign(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.sign(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = math.sign(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = math.sign(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = math.sign(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.sign(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = math.sign(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = math.sign(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = math.sign(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.SIGN: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_LENGTH(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.length(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.x    =  math.length(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.x   =  math.length(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4.x       =  math.length(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.length(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.x      =  math.length(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.x     =  math.length(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4.x         =  math.length(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.length(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.x  = math.length(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.x = math.length(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4.x     = math.length(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.length(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.x    = math.length(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.x   = math.length(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4.x       = math.length(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.LENGTH: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
            vector_size = 1;            
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_LENGTHSQ(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  math.lengthsq(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.x    =  math.lengthsq(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.x   =  math.lengthsq(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4.x       =  math.lengthsq(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  math.lengthsq(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.x      =  math.lengthsq(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.x     =  math.lengthsq(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4.x         =  math.lengthsq(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = math.lengthsq(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.x  = math.lengthsq(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.x = math.lengthsq(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4.x     = math.lengthsq(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = math.lengthsq(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.x    = math.lengthsq(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.x   = math.lengthsq(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4.x       = math.lengthsq(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.LENGTHSQ: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
            vector_size = 1;            
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_SQUARE(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  mathex.square(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  mathex.square(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  mathex.square(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  mathex.square(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  mathex.square(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  mathex.square(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  mathex.square(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  mathex.square(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = mathex.square(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = mathex.square(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = mathex.square(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = mathex.square(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = mathex.square(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = mathex.square(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = mathex.square(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = mathex.square(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.SQUARE: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_ROTATEX(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4     =  quaternion.RotateX(((float*)fdata)[0]).value;  break;

                case BlastVectorType.int1: v4       =  quaternion.RotateX(((int*)fdata)[0]).value;    break;

                case BlastVectorType.float1_n: v4   = quaternion.RotateX(-((float*)fdata)[0]).value;  break;

                case BlastVectorType.int1_n: v4     = quaternion.RotateX(-((int*)fdata)[0]).value;    break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.ROTATEX: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
            vector_size = 4;            
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_ROTATEY(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4     =  quaternion.RotateY(((float*)fdata)[0]).value;  break;

                case BlastVectorType.int1: v4       =  quaternion.RotateY(((int*)fdata)[0]).value;    break;

                case BlastVectorType.float1_n: v4   = quaternion.RotateY(-((float*)fdata)[0]).value;  break;

                case BlastVectorType.int1_n: v4     = quaternion.RotateY(-((int*)fdata)[0]).value;    break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.ROTATEY: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
            vector_size = 4;            
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_ROTATEZ(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4     =  quaternion.RotateZ(((float*)fdata)[0]).value;  break;

                case BlastVectorType.int1: v4       =  quaternion.RotateZ(((int*)fdata)[0]).value;    break;

                case BlastVectorType.float1_n: v4   = quaternion.RotateZ(-((float*)fdata)[0]).value;  break;

                case BlastVectorType.int1_n: v4     = quaternion.RotateZ(-((int*)fdata)[0]).value;    break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.ROTATEZ: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
            vector_size = 4;            
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_CONJUGATE(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float4: v4       =  math.conjugate(((float4*)fdata)[0]).value; break;
                case BlastVectorType.float4_n: v4     = math.conjugate(-((float4*)fdata)[0]).value; break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.CONJUGATE: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
            vector_size = 4;            
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_INVERSE(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float4: v4       =  math.inverse(((float4*)fdata)[0]).value; break;
                case BlastVectorType.float4_n: v4     = math.inverse(-((float4*)fdata)[0]).value; break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.INVERSE: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
            vector_size = 4;            
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_NOT(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  mathex.not(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  mathex.not(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  mathex.not(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  mathex.not(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  mathex.not(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  mathex.not(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  mathex.not(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  mathex.not(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = mathex.not(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = mathex.not(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = mathex.not(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = mathex.not(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = mathex.not(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = mathex.not(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = mathex.not(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = mathex.not(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.NOT: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_MAGNITUDE(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {

                case BlastVectorType.float1: v4.x     =  mathex.magnitude(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  mathex.magnitude(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  mathex.magnitude(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  mathex.magnitude(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  mathex.magnitude(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  mathex.magnitude(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  mathex.magnitude(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  mathex.magnitude(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = mathex.magnitude(-((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = mathex.magnitude(-((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = mathex.magnitude(-((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = mathex.magnitude(-((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = mathex.magnitude(-((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = mathex.magnitude(-((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = mathex.magnitude(-((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = mathex.magnitude(-((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {
                        Debug.LogError($"Blast.Interpretor.MAGNITUDE: vectorsize {vector_size}, datatype {datatype} not supported");
                        break;
                    }
#endif
            }
                        
        }



     

    }
}

