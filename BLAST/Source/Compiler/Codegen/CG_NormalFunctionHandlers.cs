//############################################################################################################################
// BLAST v1.0.4c                                                                                                             #
// Copyright © 2022 Rob Lemmens | NijnStein Software <rob.lemmens.s31 gmail com> All Rights Reserved                   ^__^\ #
// Unauthorized copying of this file, via any medium is strictly prohibited proprietary and confidential               (oo)\ #
//                                                                                                                     (__)  #
//############################################################################################################################
#if UNITY_EDITOR || STANDALONE_VSBUILD

using System;
using System.Collections.Generic;
using System.Text;

namespace NSS.Blast.Compiler.CodeGen
{

    /// <summary>
    /// 
    /// Only run this on mayor changes as it requires manual touches (useless to spend time on this too much)
    /// 
    /// </summary>

    static public class CG_NormalFunctionHandlers
    {

        public static string BlastSolutionFileName = "G:\\Repo\\Nijnstein\\BLAST V1\\Assets\\BLAST\\BLAST\\Source\\Interpretor\\codegen\\cg_normal_sp.cs";



        /// <summary>
        /// 0 = function name: ABS
        /// 1 = function call: math.abs
        /// </summary>

        static string single_template = @"

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void CALL_FN_{0}(ref int code_pointer, ref V4 v4, out byte vector_size, out BlastVariableDataType datatype)
        {{
            bool negated;
            code_pointer += 1;
            void* fdata = (void*)pop_p_info(ref code_pointer, out datatype, out vector_size, out bool is_negated);

            switch (datatype.Combine(vector_size, is_negated))
            {{

                case BlastVectorType.float1: v4.x     =  {1}(((float*)fdata)[0]);  break;
                case BlastVectorType.float2: v4.xy    =  {1}(((float2*)fdata)[0]); break;
                case BlastVectorType.float3: v4.xyz   =  {1}(((float3*)fdata)[0]); break;
                case BlastVectorType.float4: v4       =  {1}(((float4*)fdata)[0]); break;

                case BlastVectorType.int1: v4.x       =  {1}(((int*)fdata)[0]);    break;
                case BlastVectorType.int2: v4.xy      =  {1}(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3: v4.xyz     =  {1}(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4: v4         =  {1}(((int4*)fdata)[0]);   break;

                case BlastVectorType.float1_n: v4.x   = -{1}(((float*)fdata)[0]);  break;
                case BlastVectorType.float2_n: v4.xy  = -{1}(((float2*)fdata)[0]); break;
                case BlastVectorType.float3_n: v4.xyz = -{1}(((float3*)fdata)[0]); break;
                case BlastVectorType.float4_n: v4     = -{1}(((float4*)fdata)[0]); break;

                case BlastVectorType.int1_n: v4.x     = -{1}(((int*)fdata)[0]);    break;
                case BlastVectorType.int2_n: v4.xy    = -{1}(((int2*)fdata)[0]);   break;
                case BlastVectorType.int3_n: v4.xyz   = -{1}(((int3*)fdata)[0]);   break;
                case BlastVectorType.int4_n: v4       = -{1}(((int4*)fdata)[0]);   break;

#if DEVELOPMENT_BUILD || TRACE
                default:
                    {{
                        Debug.LogError($""Blast.Interpretor.{0}: vectorsize {{vector_size}}, datatype {{datatype}} not supported"");
                        break;
                    }}
#endif
            }}
        }}
"; 

        static string template_start = @"

// *** This file has been generated by BLAST: modification is futile an will be assimilated ***

#if STANDALONE_VSBUILD
    using NSS.Blast.Standalone;
    using System.Reflection;
#else
    using UnityEngine;
    using Unity.Burst.CompilerServices;
#endif


using Unity.Burst;
using Unity.Mathematics;
using System.Runtime.CompilerServices;

                                    
using V1 = System.Single;
using V2 = Unity.Mathematics.float2;
using V3 = Unity.Mathematics.float3;
using V4 = Unity.Mathematics.float4;


namespace NSS.Blast.Interpretor
{
    unsafe public partial struct BlastInterpretor
    {
";

        static string template_end = @"
    }
}
"; 



        static string GenSingleFunction(string function_name, string function_call)
        {
            return string.Format(single_template, function_name, function_call); 
        
        }


        static string[] singles = new string[] {
            "ABS", "math.abs", "abs", "none",
            "TRUNC", "math.trunc", "trunc", "none",
            "EXP", "math.exp", "ex_op", "exp",
            "EXP10", "math.exp10", "ex_op", "exp10",
            "LOG10", "math.log10", "ex_op", "log10",
            "LOGN", "math.log", "ex_op", "logn",
            "LOG2", "math.log2", "ex_op", "log2",
            "SQRT", "math.sqrt", "ex_op", "sqrt",
            "RSQRT", "math.rsqrt", "ex_op", "rsqrt",

            "SIN", "math.sin", "ex_op", "sin",
            "COS", "math.cos", "ex_op", "cos",
            "TAN", "math.tan", "ex_op", "tan",
            "ATAN", "math.atan", "ex_op", "atan",
            "SINH", "math.sinh", "ex_op", "sinh",
            "COSH", "math.cosh", "ex_op", "cosh",

            "DEGREES", "math.degrees", "ex_op", "degrees",
            "RADIANS", "math.radians", "ex_op", "radians",

            "SATURATE", "math.saturate", "ex_op", "saturate",
            "NORMALIZE", "math.normalize", "ex_op", "normalize",    // not all vectorsizes > only > 1

            "CEIL", "math.ceil", "ex_op", "ceil",
            "FLOOR", "math.floor", "ex_op", "floor",
            "FRAC", "math.frac", "ex_op", "frac",

            "CEILLOG2", "math.ceillog2", "ex_op", "ceillog2",       // only int 
            "CEILPOW2", "math.ceilpow2", "ex_op", "ceilpow2",       // only int 
            "FLOORLOG2", "math.floorlog2", "ex_op", "floorlog2"     // only int 
        }; 

        static public string GenerateSingles()
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine(CG_ExternalFunctionSupport.LicenseHeader);
            sb.AppendLine(template_start);                           
            for (int i = 0; i < singles.Length; i += 4)
            {
                sb.AppendLine(GenSingleFunction(singles[i], singles[i + 1]));
            }

            sb.AppendLine(template_end);
            return sb.ToString(); 








        }
            






    }
}



#endif