<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BLAST</name>
    </assembly>
    <members>
        <member name="T:NSS.Blast.BlastEngineData">
            <summary>
            BLAST execution data
            - used during execution of scripts
            - shared by all threads
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastEngineData.constants">
            <summary>
            constant values selected by opcodes and shared among threads 
            - these are set by the constant value operations and they can be replaced with other values... if you are mad
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastEngineData.Functions">
            <summary>
            external function info array. these provide api access to the script  
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastEngineData.FunctionPointers">
            <summary>
            function pointer data
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastEngineData.FunctionCount">
            <summary>
            number of function pointers in the fp array. function id's dont match indices.....  
            - TODO   this means each function call needs a lookup...
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastEngineData.random">
            <summary>
            base random number generator, all random actions have their origin in this random number generator
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastEngineData.Seed(System.UInt32)">
            <summary>
            seed the base random number generator, altering the origen for all random actions in blast 
            </summary>
            <param name="i">the new seed value</param>
        </member>
        <member name="M:NSS.Blast.BlastEngineData.GetFunction(NSS.Blast.blast_operation)">
            <summary>
            lookup function attached to operation, this assumes the function exists 
            - TODO -> we could update this to a tableindexer instead of a scan by building a lookuptable[operation] == function
            </summary>
            <param name="op">the operation to lookup the function for</param>
            <returns>function record</returns>
        </member>
        <member name="M:NSS.Blast.BlastEngineData.TryGetFunctionByName(System.String,NSS.Blast.BlastScriptFunction@)">
            <summary>
            lookup a function using its name, this uses string input so wont be burst compiled 
            </summary>
            <param name="name_match">function name to match</param>
            <param name="function">returned function</param>
            <returns>true if found</returns>
        </member>
        <member name="M:NSS.Blast.BlastEngineData.GetFunction(System.String)">
            <summary>
            get the function matching to the name 
            </summary>
            <param name="name_match">name to match</param>
            <returns>the function struct, note that it returns the default zero'd struct on matching failure</returns>
        </member>
        <member name="M:NSS.Blast.BlastEngineData.CanBeAValidFunctionId(System.Int32)">
            <summary>
            return if the id is in the correct range and its pointer is not null
            </summary>
            <param name="id">the index/id</param>
            <returns>true if possibly valid</returns>
        </member>
        <member name="M:NSS.Blast.BlastEngineData.IsVariableParamFunction(NSS.Blast.blast_operation)">
            <summary>
            lookup a function mapping to the given operation, performs a linear scan through the function table 
            </summary>
            <param name="op">the operation to lookup</param>
            <returns>returns true if the function is found and can have a variable parameter count</returns>
        </member>
        <member name="T:NSS.Blast.BlastEngineDataPtr">
            <summary>
            abstraction for enginedata pointer
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastEngineDataPtr.ptr">
            <summary>
            pointer to engine data 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastEngineDataPtr.Data">
            <summary>
            unsafe casted BlastEngineData pointer
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastEngineDataPtr.IsCreated">
            <summary>
            returns if the pointer is not null / it doesnt actually track creation
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastEngineDataPtr.op_Implicit(System.IntPtr)~NSS.Blast.BlastEngineDataPtr">
            <summary>
            implicit conversion of this to an intptr 
            </summary>
            <param name="p"></param>
        </member>
        <member name="T:NSS.Blast.Blast">
            <summary>
            Blast Engine
            </summary>
        </member>
        <member name="T:NSS.Blast.Blast.BlastExecute">
            <summary>
            delegate used to execute scripts
            </summary>
            <param name="scriptid">the id of the script</param>
            <param name="p_stack">the stack pointer</param>
            <param name="data">environment data</param>
            <param name="caller">caller data</param>
            <returns></returns>
        </member>
        <member name="F:NSS.Blast.Blast.Comment">
            <summary>
            the comment character 
            </summary>
        </member>
        <member name="F:NSS.Blast.Blast.MaximumFunctionNameLength">
            <summary>
            the maximum length of a function name in number of ASCII characters
            </summary>
        </member>
        <member name="F:NSS.Blast.Blast.InvalidNumeric">
            <summary>
            the value used for invalid numerics 
            </summary>
        </member>
        <member name="F:NSS.Blast.Blast.data">
            <summary>
            Pointer to native memory holding data used during interpretation:
            - function pointers
            - constant data 
            </summary>
        </member>
        <member name="P:NSS.Blast.Blast.IsCreated">
            <summary>
            true if the structure is initialized and memory is allocated 
            </summary>
        </member>
        <member name="P:NSS.Blast.Blast.Engine">
            <summary>
            IntPtr to global data object used by interpretor, it holds references to constant values and function pointers 
            </summary>
        </member>
        <member name="F:NSS.Blast.Blast.mt_lock">
            <summary>
            simple object/lock method for some threadsafety
            </summary>
        </member>
        <member name="M:NSS.Blast.Blast.Create(Unity.Collections.Allocator)">
            <summary>
            create a new instance of BLAST use the core scriptfunction api
            </summary>
            <param name="allocator">allocator to use, dont use temp allocator for bursted code</param>
            <returns>the blast struct</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Create(NSS.Blast.BlastScriptAPI,Unity.Collections.Allocator)">
            <summary>
            create a new instance of blast using a customized api 
            </summary>
            <param name="api">function api to use</param>
            <param name="allocator">allocator to use, dont use temp allocator for bursted code</param>
            <returns>the blast struct|class should refactor TODO</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Destroy">
            <summary>
            release all memory allocated by this instance of blast 
            </summary>
        </member>
        <member name="M:NSS.Blast.Blast.Execute(NSS.Blast.BlastPackageData@)">
            <summary>
            Execute a Package
            </summary>
            <param name="package">the package data</param>
            <returns>succes or an error code</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Execute(NSS.Blast.BlastPackageData@,System.IntPtr)">
            <summary>
            Execute a Package
            </summary>
            <param name="package">the package data to execute</param>
            <param name="environment">the environment data to use</param>
            <returns>succes or an error code</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Execute(NSS.Blast.BlastPackageData@,System.IntPtr,System.IntPtr)">
            <summary>
            Execute a Package
            </summary>
            <param name="package">the package data to execute</param>
            <param name="environment">the environment data to use</param>
            <param name="caller">the caller data to use</param>
            <returns>succes or an error code</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Execute(NSS.Blast.BlastScriptPackage@)">
            <summary>
            Execute a Package
            </summary>
            <param name="package">the package data to execute</param>
            <returns>succes or an error code</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Execute(NSS.Blast.BlastScriptPackage@,System.IntPtr)">
            <summary>
            Execute a Package
            </summary>
            <param name="package">the package data to execute</param>
            <param name="environment">the environment data to use</param>
            <returns>succes or an error code</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Execute(NSS.Blast.BlastScriptPackage@,System.IntPtr,System.IntPtr)">
            <summary>
            Execute a Package
            </summary>
            <param name="package">the package data to execute</param>
            <param name="environment">the environment data to use</param>
            <param name="caller">the caller data to use</param>
            <returns>succes or an error code</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Execute(NSS.Blast.BlastPackageData@,System.IntPtr,System.Int32)">
            <summary>
            Execute a Package in ssmd mode
            </summary>
            <param name="package">the package data to execute</param>
            <param name="ssmd_data">data for each entity|script|component</param>
            <param name="ssmd_count">the number of data elements</param>
            <returns>succes or an error code</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Execute(NSS.Blast.BlastPackageData@,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Execute a Package in ssmd mode
            </summary>
            <param name="package">the package data to execute</param>
            <param name="environment">the environment data to use</param>
            <param name="ssmd_data">data for each entity|script|component</param>
            <param name="ssmd_count">the number of data elements</param>
            <returns>succes or an error code</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Execute(NSS.Blast.BlastScriptPackage@,System.IntPtr,System.Int32)">
            <summary>
            Execute a Package in ssmd mode
            </summary>
            <param name="package">the package data to execute</param>
            <param name="ssmd_data">data for each entity|script|component</param>
            <param name="ssmd_count">the number of data elements</param>
            <returns>succes or an error code</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Execute(NSS.Blast.BlastScriptPackage@,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Execute a Package in ssmd mode
            </summary>
            <param name="package">the package data to execute</param>
            <param name="environment">the environment data to use</param>
            <param name="ssmd_data">data for each entity|script|component</param>
            <param name="ssmd_count">the number of data elements</param>
            <returns>succes or an error code</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Execute(NSS.Blast.BlastEngineDataPtr@,NSS.Blast.BlastPackageData@,System.IntPtr,System.IntPtr)">
            <summary>
            Execute a Package
            </summary>
            <param name="blast">Blast engine data</param>
            <param name="package">the package data to execute</param>
            <param name="environment">the environment data to use</param>
            <param name="caller"></param>
            <returns>succes or an error code</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Execute(NSS.Blast.BlastEngineDataPtr@,NSS.Blast.BlastPackageData@,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Execute a Package in ssmd mode
            </summary>
            <param name="blast"></param>
            <param name="package">the package data to execute</param>
            <param name="environment">the environment data to use</param>
            <param name="ssmd_data">data for each entity|script|component</param>
            <param name="ssmd_count">the number of data elements</param>
            <returns>succes or an error code</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Package(System.String,NSS.Blast.BlastCompilerOptions)">
            <summary>
            Complile the code and package into blastscriptpackage 
            </summary>
            <param name="code">the script code</param>
            <param name="options">compiler options</param>
            <returns>the blastscript package</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Package(NSS.Blast.BlastScript,NSS.Blast.BlastCompilerOptions)">
            <summary>
            Compile and package the script 
            </summary>
            <param name="script">the script to compile</param>
            <param name="options">compiler options</param>
            <returns>the blastscript package</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Package(NSS.Blast.BlastEngineDataPtr,System.String,NSS.Blast.BlastCompilerOptions)">
            <summary>
            Compile and package script code
            </summary>
            <param name="blast">blast engine data</param>
            <param name="code">script code to compile</param>
            <param name="options">compiler options</param>
            <returns>the code packaged and ready to execute</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Package(NSS.Blast.BlastEngineDataPtr,NSS.Blast.BlastScript,NSS.Blast.BlastCompilerOptions)">
            <summary>
            Compile and package script code
            </summary>
            <param name="blast">blast engine data</param>
            <param name="script">script code to compile</param>
            <param name="options">compiler options</param>
            <returns>the code packaged and ready to execute</returns>
        </member>
        <member name="M:NSS.Blast.Blast.Intermediate(NSS.Blast.BlastEngineDataPtr,NSS.Blast.BlastScript,NSS.Blast.BlastCompilerOptions)">
            <summary>
            compile the compiler intermediate
            </summary>
            <param name="blast">blast engine data</param>
            <param name="script">script</param>
            <param name="options">compiler options</param>
            <returns></returns>
        </member>
        <member name="F:NSS.Blast.Blast.ValueOperations">
            <summary>
            list all value operations, these operations directly encode constant values 
            -> burst should be able to access this if needed.. 
            </summary>
        </member>
        <member name="M:NSS.Blast.Blast.GetConstantValue(NSS.Blast.blast_operation)">
            <summary>
            get the constant numeric value of the operation 
            </summary>
            <param name="op">the operation to return the constant for</param>
            <returns>a constant float value</returns>
        </member>
        <member name="M:NSS.Blast.Blast.GetConstantValueOperation(System.String,System.Single)">
            <summary>
            get the script_op belonging to a constant value, eiter by name or value 
            </summary>
            <param name="value">the value to match</param>
            <param name="constant_epsilon">the epsilon to use matching constant values</param>
            <returns>nop on no match, nan of not a string match and no float, operation on match</returns>
        </member>
        <member name="M:NSS.Blast.Blast.IsNamedSystemConstant(System.String)">
            <summary>
            check if name matches a named system constant like  'PI' or 'NaN'
            </summary>                                                   
        </member>
        <member name="M:NSS.Blast.Blast.GetNamedSystemConstantValue(System.String)">
            <summary>
            get the value of a named system constant 
            </summary>
        </member>
        <member name="F:NSS.Blast.Blast.Tokens">
            <summary>
            defines tokens that can be used in script, not all tokens are referenced here, only those not built on keywords (if then/ switch etc.)
            </summary>
        </member>
        <member name="F:NSS.Blast.Blast.ReservedWords">
            <summary>
            Reserverd words by BLAST Script 
            </summary>
            <remarks>
            Reserved words are keywords used by blast to identify built in (flow)control operations:
            <code>
            
            Flow control:
                IF THEN ELSE
                SWITCH CASE DEFAULT    
                WHILE | FOR
                
            Compiler control:
                DEFINE 
                INPUT
                OUTPUT
                VALIDATE
            
            And any defined function name.
            
            </code>
            
            </remarks>
        </member>
        <member name="M:NSS.Blast.Blast.IsJumpOperation(NSS.Blast.blast_operation)">
            <summary>
            check if the operation is a jump (jz, jnz, jump, jump_back)
            </summary>
            <param name="op">operation to check</param>
            <returns>true if a jump</returns>
        </member>
        <member name="M:NSS.Blast.Blast.IsConstantJumpOperation(NSS.Blast.blast_operation)">
            <summary>
            check if the operation is a jump (jz, jnz, jump, jump_back)
            </summary>
            <param name="op">operation to check</param>
            <returns>true if a jump</returns>
        </member>
        <member name="M:NSS.Blast.Blast.IsOperationSSMDHandled(NSS.Blast.blast_operation)">
             <summary>
             returns true for ssmd valid operations: 
             
                    add = 2,  
                    substract = 3,
                    divide = 4,
                    multiply = 5,
                    and = 6,
                    or = 7,
                    not = 8,
                    xor = 9,
            
                    greater = 10,
                    greater_equals = 11,
                    smaller = 12,
                    smaller_equals,
                    equals,
                    not_equals
                    
             </summary>
             <param name="op">the operation to check</param>
             <returns>true if handled by the ssmd interpretor</returns>
        </member>
        <member name="M:NSS.Blast.Blast.VisualizeTokens(System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}},System.Int32,System.Int32)">
            <summary>
            visualize a list of tokens and identifiers into a somewhat readable string
            </summary>
            <param name="tokens">the tuples with token and identifier</param>
            <param name="idx">start of range to view</param>
            <param name="idx_max">end of range to view</param>
            <returns>a single line string with token descriptions</returns>
        </member>
        <member name="M:NSS.Blast.Blast.GetBlastOperationFromToken(NSS.Blast.BlastScriptToken)">
            <summary>
            get the corresponding operation opcode from a given script token 
            </summary>
            <param name="token">the script token</param>
            <returns>corresponding opcode</returns>
        </member>
        <member name="M:NSS.Blast.Blast.GetSequenceOperation(NSS.Blast.blast_operation)">
            <summary>
            get the function for a sequence of op, add -> adda
            </summary>
        </member>
        <member name="M:NSS.Blast.Blast.HasSequenceOperation(NSS.Blast.blast_operation)">
            <summary>
            return if there is a sequence function for the operation
            </summary>
        </member>
        <member name="F:NSS.Blast.Blast.API">
            <summary>
            the current set of script accessible functions, check OwnScriptAPIMemory to see if this instance of blast is the owner of the memory used in the API
            </summary>
        </member>
        <member name="F:NSS.Blast.Blast.OwnScriptAPIMemory">
            <summary>
            true if memory is owned by this instance of blast and should be destroyed with it 
            </summary>
        </member>
        <member name="P:NSS.Blast.Blast.Scripts">
            <summary>
            Enumerates all scripts known by blast 
            </summary>
        </member>
        <member name="M:NSS.Blast.Blast.CompileIntoDesignTimeRegistry(NSS.Blast.BlastEngineDataPtr,NSS.Blast.BlastScript,System.String)">
            <summary>
            compile the script into the designtime registry 
            </summary>
            <param name="blast">blast engine data</param>
            <param name="script">the script to compile</param>
            <param name="script_directory">the directory to place the script in</param>
            <returns>true on success</returns>
        </member>
        <member name="M:NSS.Blast.Blast.GetReadableByteCode(System.Byte*@,System.Int32@)">
            <summary>
            get somewhat readable assembly from bytes
            </summary>
            <param name="bytes"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Blast.IsError(NSS.Blast.BlastError)">
            <summary>
            return if an error (!yield and !success)
            </summary>
            <param name="res"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Blast.IsSuccess(NSS.Blast.BlastError)">
            <summary>
            return if an error code actually means success 
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastScript">
            <summary>
            A BLAST Script
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScript.LanguageVersion">
            <summary>
            Target language vesion, depending on compilation settings it might change in the package
            but the user should ensure that the code is compatible; 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScript.Id">
            <summary>
            Blast scriptid, used to uniquely identify the script. It is used throughout blast to id the packaged script
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScript.Name">
            <summary>
            The name of the script as used in messages 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScript.Code">
            <summary>
            the actual scriptcode conforming to the languageversion set
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScript.Package">
            <summary>
            native package data, contains references to code and data segments 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScript.IsPackaged">
            <summary>
             true if the script has been packaged / prepared
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScript.IsPrepared">
            <summary>
             true if the script has been packaged / prepared
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScript.FromText(System.String,System.String,System.Int32)">
            <summary>
            create script object from code 
            </summary>
            <param name="code">the code</param>
            <param name="name">name for the script</param>
            <param name="id">a unique id</param>
            <returns>a blast script</returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.Prepare(System.IntPtr)">
            <summary>
            Prepare the script for execution
            </summary>
            <param name="blast">blast engine data</param>
            <returns>success if all is ok </returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.Execute(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            execute the script in the given environment with the supplied data
            </summary>
            <param name="blast">blastengine data</param>
            <param name="environment">[optional] pointer to environment data</param>
            <param name="caller">[ooptional] caller data</param>
            <returns>success if all is ok</returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.ToString">
            <summary>
            get the string representation of a blast script as ID:Name
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScript.Dispose">
            <summary>
            cleanup package data if allocated on dispose 
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScript.ReleasePackage">
            <summary>
            release package memory, nulls reference to it and free;s any native package memory with it 
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetVariable(System.Int32,System.Boolean)">
            <summary>
            Lookup a variable by its index, the script must be prepared first
            </summary>
            <param name="index">the variable index</param>
            <param name="assert_on_fail">disable assertion on failure to lookup variable</param>
            <returns>BlastVariable or null on errors in release (asserts in debug)</returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetVariable(System.String,System.Boolean)">
            <summary>
            Lookup a variable by its name, the script must be prepared first, this will assert if the name does not exist or return null on failure
            </summary>
            <param name="name">the name</param>
            <param name="assert_on_fail">disable assertion on failure to lookup variable</param>
            <returns>BlastVariable or null on errors in release (asserts in debug)</returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetVariableCount">
            <summary>
            Get the number of variables defined by the script, the script must be prepared first 
            </summary>
            <returns>the number of variables in the script</returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetVariableOffset(System.Int32@)">
            <summary>
            get offset of given variable
            </summary>
            <param name="variable_index">index of variable</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetInputCount">
            <summary>
            get number of variables that are defined as input 
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetInput(System.Int32@)">
            <summary>
            get variable representing input_index 
            </summary>
            <param name="input_index"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetInputOffset(System.Int32@)">
            <summary>
            get offset of given input
            </summary>
            <param name="input_index"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetFloat(System.Int32@)">
            <summary>
            get a float input/output value, asserts on errors
            </summary>
            <param name="input_index"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetFloat2(System.Int32@)">
            <summary>
            get a float2 input/output value, asserts on errors
            </summary>
            <param name="input_index"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetFloat3(System.Int32@)">
            <summary>
            get a float3 input/output value, asserts on errors
            </summary>
            <param name="input_index"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetFloat4(System.Int32@)">
            <summary>
            get a float4 input/output value, asserts on errors
            </summary>
            <param name="input_index"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.SetData(System.Int32@,Unity.Collections.NativeArray{NSS.Blast.BlastPackageData}@,Unity.Collections.NativeArray{System.Single}@)">
            <summary>
            set variable in package data
            </summary>
            <param name="variable_offset">the variable offset</param>
            <param name="packages">array of package data</param>
            <param name="data">array of float data to fill</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.SetData(System.Int32@,Unity.Collections.NativeArray{NSS.Blast.BlastPackageData}@,Unity.Collections.NativeArray{Unity.Mathematics.float2}@)">
            <summary>
            set variable in package data
            </summary>
            <param name="variable_offset">the variable offset</param>
            <param name="packages">array of package data</param>
            <param name="data">array of float2 data to fill</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.SetData(System.Int32@,Unity.Collections.NativeArray{NSS.Blast.BlastPackageData}@,Unity.Collections.NativeArray{Unity.Mathematics.float3}@)">
            <summary>
            set variable in package data
            </summary>
            <param name="variable_offset">the variable offset</param>
            <param name="packages">array of package data</param>
            <param name="data">array of float2 data to fill</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.SetData(System.Int32@,Unity.Collections.NativeArray{NSS.Blast.BlastPackageData}@,Unity.Collections.NativeArray{Unity.Mathematics.float4}@)">
            <summary>
            set variable in package data
            </summary>
            <param name="variable_offset">the variable offset</param>
            <param name="packages">array of package data</param>
            <param name="data">array of float2 data to fill</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetData(System.Int32@,Unity.Collections.NativeArray{NSS.Blast.BlastPackageData}@,Unity.Collections.NativeArray{System.Single}@)">
            <summary>
            get all data for a given variable offset for a collection of packages 
            </summary>
            <param name="variable_offset">the offset of the variable into the datasegment</param>
            <param name="packages">the packages to get the data from</param>
            <param name="data">the output to write to</param>
            <returns>true if ok, false on errors</returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetData(System.Int32@,Unity.Collections.NativeArray{NSS.Blast.BlastPackageData}@,Unity.Collections.NativeArray{Unity.Mathematics.float2}@,System.Int32)">
            <summary>
            get all data for a given variable offset for a collection of packages 
            </summary>
            <param name="variable_offset">the offset of the variable into the datasegment</param>
            <param name="packages">the packages to get the data from</param>
            <param name="data">the output to write to</param>
            <param name="offset">the offset into output from where to start writing output data</param>
            <returns>true if ok, false on errors</returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetData(System.Int32@,Unity.Collections.NativeArray{NSS.Blast.BlastPackageData}@,Unity.Collections.NativeArray{Unity.Mathematics.float3}@,System.Int32)">
            <summary>
            get all data for a given variable offset for a collection of packages 
            </summary>
            <param name="variable_offset">the offset of the into the datasegment</param>
            <param name="packages">the packages to get the data from</param>
            <param name="data">the output to write to</param>
            <param name="offset">the offset into output from where to start writing output data</param>
            <returns>true if ok, false on errors</returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetData(System.Int32@,Unity.Collections.NativeArray{NSS.Blast.BlastPackageData}@,Unity.Collections.NativeArray{Unity.Mathematics.float4}@,System.Int32)">
            <summary>
            get all data for a given input offset for a collection of packages 
            </summary>
            <param name="variable_offset">the offset of the input into the datasegment</param>
            <param name="packages">the packages to get the data from</param>
            <param name="data">the output to write to</param>
            <param name="offset">the offset into output from where to start writing output data</param>
            <returns>true if ok, false on errors</returns>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetDataPointer(System.Single*@,System.Int32@)">
            <summary>
            get a direct pointer to the data in the package 
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScript.GetDataPointer(NSS.Blast.BlastPackageData@,System.Single*@,System.Int32@)">
            <summary>
            get a direct pointer to the data in the package 
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastCompilerStageType">
            <summary>
            the types of compiler stages that run in sequence to produce the output
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.None">
            <summary>
            unknown - not set
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.Tokenizer">
            <summary>
            convert input script into a list of tokens 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.Parser">
            <summary>
            parses the tokens into an ast-tree
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.IdentifierMapping">
            <summary>
            identify all identifiers 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.Transform">
            <summary>
            transform constructs in the ast: switch -> ifthen, while,for, etc -> ifthen 
            making later stages having less to worry about 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.ParameterAnalysis">
            <summary>
            analyse parameter use
            - determine vectors 
            - enforce multiplication rules 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.Analysis">
            <summary>
            analyze ast structure
            - basic removal of some useless structures
            - rules of multiplication
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.Flatten">
            <summary>
            flatten execution path 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.Optimization">
            <summary>
            optimize ast structure
            - transform expensive constructs into less expensive ones
            - this should be done after flattening the tree, any optimization that reduces compounds should happen in analysis
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.Cleanup">
            <summary>
            pre compile cleanup 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.StackResolver">
            <summary>
            resolve stack operations into stack-variables (HPC/CS only)
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.Compile">
            <summary>
            a [bytecode/hpc/cs] compiler
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.BytecodeOptimizer">
            <summary>
            post-compile: bytecode optimizer
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.JumpResolver">
            <summary>
            post-compile: resolve jumps 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.Stage.BlastCompilerStageType.Packaging">
            <summary>
            post-compile: package result
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.IBlastCompilerStage">
            <summary>
            a compiler stage - employs 1 step of the compilation process
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.IBlastCompilerStage.Version">
            <summary>
            stage version, for future differentiation 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.IBlastCompilerStage.StageType">
            <summary>
            the type of stage implemented 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.IBlastCompilerStage.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            execute interface 
            </summary>
            <param name="data">compiler data object</param>
            <returns>blasterror code|success</returns>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastAnalysis">
            <summary>
            Basic Node Analysis 
            - force multiplication rules 
            - simplifies arithmetic 
            - refactors divisions 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastAnalysis.Version">
            <summary>
            version 0.1
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastAnalysis.StageType">
            <summary>
            perform basic analysis 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastAnalysis.simplify_compound_arithmetic(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            simplify non-vector non-function compounds by removing nested compounds when operations allow it. 
            
            -> all operations equal then move compound up, returns nr of moves made
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastAnalysis.refactor_divisions(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
             refactor divisions into multiplications with inverse of constants where possible 
            </summary>
            <param name="data"></param>
            <param name="n"></param>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastAnalysis.apply_multiplication_rules(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            apply rules of multiplication if needed to children of this node 
            </summary>
            <param name="data"></param>
            <param name="n"></param>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastAnalysis.simplify_node(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            simplify nodes until no changes occur 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastAnalysis.analyze_node(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            analyze a node and its children, can be run in parallel on different node roots
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastAnalysis.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            analyse ast tree and perform corrections/optimizations 
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastIdentifierMapping">
            <summary>
            Parameter Analysis
            - determine parameter types (float, vectorsize) 
            - confirm inputs used (warnings if not) and outputs set (not set = error)
            - validate correct parameter usage
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastIdentifierMapping.Version">
            <summary>
            v0.1.0 - initial version
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastIdentifierMapping.StageType">
            <summary>
            compiler stage: parameter analysis
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastIdentifierMapping.map_inline_identifier(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            check mapping of inlined function
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastIdentifierMapping.map_identifiers(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            map identifiers to variables
            - determine if a opcode constant (1,2 , pi and stuff) or just a constant number on the data stack 
            </summary>
            <param name="data">compiler data</param>
            <param name="ast_node">the node to scan including child nodes</param>
            <returns>true if succeeded / IsOK</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastIdentifierMapping.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
             
            </summary>
            <param name="data">current compilationdata</param>
            <returns>0 for success, other exitcode = error</returns>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastBytecodeCompiler">
            <summary>
            Blast Compiler Stage 
            - compiles the ast into bytecode
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastBytecodeCompiler.Version">
            <summary>
            Version 0.1.0 - Initial 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastBytecodeCompiler.StageType">
            <summary>
            Compilation Stage
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastBytecodeCompiler.GetOperationOpCode(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.BlastScriptToken)">
            <summary>
            translate a token representing an operation into its matching opcode, logs an error if operation cant be mapped
            </summary>
            <param name="data"></param>
            <param name="token">the token to map</param>
            <returns>script opcode</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastBytecodeCompiler.CompileParameter(NSS.Blast.Compiler.CompilationData,NSS.Blast.Compiler.node,NSS.Blast.Compiler.Stage.IMByteCodeList,System.Boolean)">
            <summary>
            compile a single parameter node into the code stream
            </summary>
            <param name="data"></param>
            <param name="ast_param">the parameter node</param>
            <param name="code">the code to append to</param>
            <param name="allow_pop"></param>
            <returns>false on failure</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastBytecodeCompiler.CompileParameters(NSS.Blast.Compiler.CompilationData,NSS.Blast.Compiler.node,NSS.Blast.Compiler.Stage.IMByteCodeList,System.Collections.Generic.IEnumerable{NSS.Blast.Compiler.node},System.Int32,System.Int32)">
            <summary>
            compile a list of nodes as a list of parameters
            </summary>
            <param name="data"></param>
            <param name="ast_function">the node with the function</param>
            <param name="code">the bytecode to add compiled code to</param>
            <param name="parameter_nodes">the parameter list</param>
            <param name="min_validate">min parameter count, error will be raised if less</param>
            <param name="max_validate">max parameter count, error will be raised if more</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastBytecodeCompiler.CompileSimplexFunctionParameterList(NSS.Blast.Compiler.CompilationData,NSS.Blast.Compiler.node,System.Collections.Generic.List{NSS.Blast.Compiler.node},NSS.Blast.Compiler.Stage.IMByteCodeList)">
            <summary>
            Compile a list of parameters as they are typically supplied to a function into a code stream 
            - the parameters are all assumed to be simplex
            </summary>
            <param name="data">compiler data</param>
            <param name="ast_function">ast function node</param>
            <param name="children">child nodes to render, dont need to be children of the node</param>
            <param name="code">the code list to output to</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastBytecodeCompiler.CompileFunction(NSS.Blast.Compiler.CompilationData,NSS.Blast.Compiler.node,NSS.Blast.Compiler.Stage.IMByteCodeList)">
            <summary>
            Compile a function and its parameters 
            </summary>
            <param name="data"></param>
            <param name="ast_function">the node/function to compile</param>
            <param name="code"></param>
            <returns>true on success, false otherwise, errors will be logged in data</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastBytecodeCompiler.CompileNode(NSS.Blast.Compiler.CompilationData,NSS.Blast.Compiler.node,NSS.Blast.Compiler.Stage.IMByteCodeList)">
            <summary>
            Compile a node into bytecode 
            </summary>
            <param name="data"></param>
            <param name="ast_node">the node to compile, may not be the root ast node</param>
            <param name="code">an optional existing codelist to append to</param>
            <returns>an intermediate bytecode list</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastBytecodeCompiler.AnalyzeCompoundNesting(NSS.Blast.Compiler.CompilationData,NSS.Blast.Compiler.node)">
            <summary>
            analyze node tree structure, find any nested compound that shouldnt be 
            - fix simple cases
            - error on others 
            - this 'analysis' must always run independant of analyzer 
            </summary>
            <param name="data">compiler data</param>
            <param name="root">root to start from</param>
            <returns>success or error code</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastBytecodeCompiler.CompileNodes(NSS.Blast.Compiler.CompilationData,NSS.Blast.Compiler.node)">
            <summary>
            compile all nodes in the given root node into intermediate bytecode
            - if allowed by options, all child nodes will be processed in parallel
            </summary>
            <param name="data">compiler data</param>
            <param name="ast_root">the root node to compile</param>
            <returns>a list with bytecode possibly with extra data, hence intermediate bytecode</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastBytecodeCompiler.CompileAST(NSS.Blast.Compiler.CompilationData)">
            <summary>
            Compile the abstract syntax tree into bytecode
            </summary>
            <param name="data">compilerdata, among which the AST</param>
            <returns>a list of bytecode, null on failure</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastBytecodeCompiler.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            Execute the compilation stage, prepares bytecode from the AST
            </summary>
            <param name="data">compiler data</param>
            <returns>non zero on error conditions</returns>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastJumpResolver">
            <summary>
            Resolve Jumps
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastJumpResolver.ResolveJumps(NSS.Blast.Compiler.CompilationData,NSS.Blast.Compiler.Stage.IMByteCodeList)">
            <summary>
            Resolve all jumps
            </summary>
            <param name="cdata">compilation data</param>
            <param name="code">intermediate bytecode</param>
            <returns>true on success</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastJumpResolver.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            resolve all jumps - connect jump-offsets with jump labels
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastBytecodeOptimizer">
            <summary>
            Bytecode Optimizer
            - optimizes bytecode based on pattern recognition
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastBytecodeOptimizer.optimizer_pattern.match(NSS.Blast.Compiler.CompilationData,NSS.Blast.Compiler.Stage.IMByteCodeList,System.Int32,NSS.Blast.Compiler.Stage.BlastBytecodeOptimizer.optimizer_pattern@)">
            <summary>
            match pattern at i
            </summary>
            <param name="result"></param>
            <param name="ops"></param>
            <param name="i"></param>
            <param name="matched_pattern"></param>
            <returns>true on match</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastBytecodeOptimizer.OptimizePatterns(NSS.Blast.Compiler.CompilationData,NSS.Blast.Compiler.Stage.IMByteCodeList)">
            <summary>
            scan and replace patterns 
            </summary>
            <param name="data">compiler data</param>
            <param name="code">code to optimize</param>
            <returns>false on failure, logs errors in compilerdata</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastBytecodeOptimizer.Optimize(NSS.Blast.Compiler.CompilationData)">
            <summary>
            optimize all code segments 
            </summary>
            <param name="cdata"></param>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastBytecodeOptimizer.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            execute the bytecode optimizer 
            </summary>
            <param name="data">compilationdata with code set</param>
            <returns>nonzero exitcode on failure</returns>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastPreCompileCleanup">
            <summary>
            Pre-Compile Cleanup
            - for now only cleans up parameter references 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastPreCompileCleanup.Version">
            <summary>
            version 0.1
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastPreCompileCleanup.StageType">
            <summary>
            cleanup stage -> mainly cleans up references 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastPreCompileCleanup.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            execute cleanup procedures 
            </summary>        
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastCSCompiler.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            compile script using the cs compiler supplied with .net
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastFlatten">
            <summary>
            Flatten Nodes 
            - removes all nested things and reduces them to a linear stream of instructions using stack operations 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastFlatten.Version">
            <summary>
            Version 1
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastFlatten.StageType">
            <summary>
            Flatten Stage
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastFlatten.FlattenCompound(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node@,System.Collections.Generic.List{NSS.Blast.Compiler.node}@)">
            <summary>
            flatten a compound 
            </summary>
            <param name="data"></param>
            <param name="compound"></param>
            <param name="flattened_output"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastFlatten.FlattenFunctionParameters(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node@,System.Collections.Generic.List{NSS.Blast.Compiler.node}@)">
            <summary>
            flatten a list of function parameters 
            </summary>
            <param name="data"></param>
            <param name="function"></param>
            <param name="flattened_output"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastFlatten.FlattenFunction(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node@,System.Collections.Generic.List{NSS.Blast.Compiler.node}@,System.Boolean,NSS.Blast.Compiler.node@)">
            <summary>
            flatten a function into a list of flat operations, its optional to push the resulting function to the end of the list and return the pushing node reference 
            </summary>
            <param name="data"></param>
            <param name="function"></param>
            <param name="flattened_output"></param>
            <param name="push_function"></param>
            <param name="pusher"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastFlatten.FlattenAssignment(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node@,System.Collections.Generic.List{NSS.Blast.Compiler.node}@,System.Boolean,NSS.Blast.Compiler.node@)">
            <summary>
            flatten assignement node 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastFlatten.FlattenWhileLoop(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            flatten a while loop (which might originally have been a for loop dueue to transform stage) 
            - pops away operations from condition 
            - generates flat list of statements for loop compound 
            - maintains same root object 
            --- THE WHILELOOP SHOULD BE EXCLUDED FROM NESTING TESTS
            --- while this nests in the node tree it nests control flow and that will flatten out when compiling into jumps
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastFlatten.FlattenIfThenElse(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            flatten an ifthenelse construct 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastFlatten.FlattenStatements(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node,System.Collections.Generic.List{NSS.Blast.Compiler.node}@)">
            <summary>
            Flatten the statement
            </summary>
            <param name="data"></param>
            <param name="root"></param>
            <param name="flat"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastFlatten.FlattenRoot(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="root"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastFlatten.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastHPCCompiler">
            <summary>
            Blast Compiler Stage                                       
            - compiles the ast into hpc code for compile-time scripts 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastHPCCompiler.Version">
            <summary>
            Version 0.1
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastHPCCompiler.StageType">
            <summary>
            = HPC Compilation Stage 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastHPCCompiler.GetOperationString(NSS.Blast.Compiler.CompilationData,NSS.Blast.BlastScriptToken)">
            <summary>
            Get a string representing the token in the target
            </summary>
            <param name="data">compiler data (logging)</param>
            <param name="token">the token to translate</param>
            <returns>the operation translated to target operation text</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastHPCCompiler.GetFunctionName(NSS.Blast.Compiler.CompilationData,NSS.Blast.BlastScriptFunction)">
            <summary>
            get the name of the function in the target hpc 
            </summary>
            <param name="data">compilation data</param>
            <param name="function">the function to get the name for</param>
            <returns>the hpc function name </returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastHPCCompiler.CompileParameter(NSS.Blast.Compiler.CompilationData,NSS.Blast.Compiler.node,System.Text.StringBuilder)">
            <summary>
            compile a single parameter node into the code stream
            </summary>
            <param name="data"></param>
            <param name="ast_param">the parameter node</param>
            <param name="code">the code to append to</param>
            <returns>false on failure</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastHPCCompiler.CompileParameters(NSS.Blast.Compiler.CompilationData,NSS.Blast.Compiler.node,System.Text.StringBuilder,System.Collections.Generic.IEnumerable{NSS.Blast.Compiler.node},System.Int32,System.Int32)">
            <summary>
            compile a list of nodes as a list of parameters
            </summary>
            <param name="data"></param>
            <param name="ast_node">the node with the function</param>
            <param name="code">the stringbuilder to add hpc code to</param>
            <param name="parameter_nodes">the parameter list</param>
            <param name="min_validate">min parameter count, error will be raised if less</param>
            <param name="max_validate">max parameter count, error will be raised if more</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastHPCCompiler.CompileAST(NSS.Blast.Compiler.HPCCompilationData,System.Int32)">
            <summary>
            Compile the abstract syntax tree into a c# job to be used as hpc for burst by unity
            </summary>
            <param name="data">compilerdata, among which the AST</param>
            <param name="indent">indentation used in output</param>
            <returns>a string containg the code</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastHPCCompiler.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            Execute the compilation stage, prepares c# code ready for the burst compiler
            </summary>
            <param name="data">compiler data</param>
            <returns>non zero on error conditions</returns>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastHPCStackResolver">
            <summary>
            Stack Resolver for HPC code
            - transmute push-pops to stack-var assignments
            - re-use variables as much as possible  
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.IMByteCode">
            <summary>
            intermediate bytecode - can contain additional data
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.IMByteCode.code">
            <summary>
            the bytecode
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.IMByteCode.op">
            <summary>
            possible translation
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.IMByteCode.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.IMByteCodeList">
            <summary>
            list of intermediate bytecode
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.IMByteCodeList.segments">
            <summary>
            segments, used when compiling multithreaded;
            the compiler will build a tree of codelists with segments 
            after that following stages might run using multithreading on the segments 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.IMByteCodeList.Add(System.Byte,NSS.Blast.Compiler.IMJumpLabel)">
            <summary>
            add code to list
            </summary>
            <param name="code">the opcode byte</param>
            <param name="label">optional jump label</param>
            <returns>returns index of opcode</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.IMByteCodeList.Add(NSS.Blast.blast_operation,NSS.Blast.Compiler.IMJumpLabel)">
            <summary>
            add op to code list
            </summary>
            <param name="op"></param>
            <param name="label">optional jump label</param>
            <returns>the index of the op</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.IMByteCodeList.ReduceSegments">
            <summary>
            add all segments to this list clearing the segment list afterwards 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.IMByteCodeList.Item(System.Int32)">
            <summary>
            get opcode at index
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.IMByteCodeList.Count">
            <summary>
            get count of opcodes
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastOptimizer">
            <summary>
            Basic Optimization Stage 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastOptimizer.Version">
            <summary>
            V0.1.0 - initial version 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastOptimizer.StageType">
            <summary>
            optimizer stage 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastOptimizer.ReplaceSequence(NSS.Blast.BlastEngineDataPtr,NSS.Blast.Compiler.node,NSS.Blast.blast_operation,NSS.Blast.blast_operation,System.Int32,System.Int32)">
            <summary>
            replace sequence IN PLACE with a function 
            </summary>
            <param name="blast">blast engine data -> needs access to functions</param>
            <param name="node">node to be updated</param>
            <param name="singleop">the singleop</param>
            <param name="replacement_function">the replacement fucntion</param>
            <param name="from">only use childnodes starting from this index</param>
            <param name="operation_count">the number of operations to replace if > 0</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastOptimizer.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            Optimize operations expressed by the ast if optimization is enabled through compiler settings 
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastPackaging">
            <summary>
            Package Stage: process compiled bytecode into packages 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastPackaging.Version">
            <summary>
            Version 0.1
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastPackaging.StageType">
            <summary>
            Packaging Stage -> creates package 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastPackaging.PackageIntermediate(NSS.Blast.Compiler.CompilationData,NSS.Blast.Compiler.Stage.IMByteCodeList)">
            <summary>
            package the compiled code into BlastIntermediate 
            </summary>
            <param name="cdata"></param>
            <param name="code">the code to package</param>
            <returns>non-zero error code on failure</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastPackaging.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            package bytecode into script package
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastParameterAnalysis">
            <summary>
            Parameter Analysis
            - determine parameter types (float, vectorsize) 
            - confirm inputs used (warnings if not) and outputs set (not set = error)
            - validate correct parameter usage
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastParameterAnalysis.Version">
            <summary>
            v0.1.0 - initial version
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastParameterAnalysis.StageType">
            <summary>
            compiler stage: parameter analysis
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParameterAnalysis.check_if_vector(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            perform a check to see if a node results in a vector
            </summary>
            <param name="data"></param>
            <param name="leaf_node"></param>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParameterAnalysis.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            the parameter analyzer only looks at the parameters and their usage 
            - !! it wont make any node changes !!
            - checks vectorsizes
            - checks input/output settings 
            - 
            </summary>
            <param name="data">current compilationdata</param>
            <returns>0 for success, other exitcode = error</returns>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastParser">
            <summary>
            The Parser: 
            
            - Parses list of tokens into a tree of nodes representing the flow of operations  
            - Identifies unique parameters 
            - Spaghetti warning - handcrafted parser ahead..
            
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastParser.Version">
            <summary>
            version 0.2.1
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastParser.StageType">
            <summary>
            parsing stage: transforms token list into a node tree
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.find_next(NSS.Blast.Compiler.IBlastCompilationData,System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}},NSS.Blast.BlastScriptToken,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            scan for the next token of type 
            </summary>
            <param name="data"></param>
            <param name="tokens">token list to search in</param>
            <param name="token">token to look for</param>
            <param name="idx">idx to start looking from</param>
            <param name="max">max idx to look into</param>
            <param name="i1">idx of token</param>
            <returns>true if found</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.find_next(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.BlastScriptToken[],System.Int32,System.Int32@,System.Int32@)">
            <summary>
            scan for the next token of type 
            </summary>
            <param name="data"></param>
            <param name="tokens">token to look for</param>
            <param name="idx">idx to start looking from</param>
            <param name="max">max idx to look into</param>
            <param name="i1">idx of token</param>
            <returns>true if found</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.find_next_skip_compound(NSS.Blast.Compiler.IBlastCompilationData,System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}},NSS.Blast.BlastScriptToken,System.Int32,System.Int32@,System.Int32@,System.Boolean)">
            <summary>
            search for the next token skipping over compounds 
            </summary>
            <param name="data"></param>
            <param name="tokens">token list to use</param>
            <param name="token">token to look for</param>
            <param name="idx">idx to start looking from</param>
            <param name="max">max idx to look into</param>
            <param name="i1">idx of token</param>
            <param name="accept_eof"></param>
            <returns>true if found</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.find_next_skip_compound(NSS.Blast.Compiler.IBlastCompilationData,System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}},NSS.Blast.BlastScriptToken[],System.Int32,System.Int32@,System.Int32@,System.Boolean)">
            <summary>
            search for the next token skipping over compounds 
            </summary>
            <param name="data"></param>
            <param name="tokenlist"></param>
            <param name="tokens">token to look for</param>
            <param name="idx">idx to start looking from</param>
            <param name="max">max idx to look into</param>
            <param name="i1">idx of token</param>
            <param name="accept_eof"></param>
            <returns>true if found</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.find_next(NSS.Blast.Compiler.IBlastCompilationData,System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}},NSS.Blast.BlastScriptToken,System.Int32,System.Int32@,System.Int32@,System.Boolean,System.Boolean)">
            <summary>
            find next token from idx 
            </summary>
            <param name="data"></param>
            <param name="tokens"></param>
            <param name="token"></param>
            <param name="idx">idx to start looking from</param>
            <param name="max">max index to check into</param>
            <param name="i1">token location or -1 if not found</param>
            <param name="skip_over_compounds">skip over ( ) not counting any token inside the (compound)</param>
            <param name="accept_eof">accept eof as succesfull end of search</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.find_next(NSS.Blast.Compiler.IBlastCompilationData,System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}},NSS.Blast.BlastScriptToken[],System.Int32,System.Int32@,System.Int32@,System.Boolean,System.Boolean)">
            <summary>
            find next match in token array 
            </summary>
            <param name="data"></param>
            <param name="tokenlist"></param>
            <param name="tokens"></param>
            <param name="idx">idx to start looking from</param>
            <param name="max">max index to check into</param>
            <param name="i1">token location or -1 if not found</param>
            <param name="skip_over_compounds">skip over ( ) not counting any token inside the (compound)</param>
            <param name="accept_eof">accept eof as succesfull end of search</param>        /// <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.skip_closure(NSS.Blast.Compiler.IBlastCompilationData,System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}},System.Int32@,System.Int32)">
            <summary>
            skip the closure () starting with idx at the (, if true ends with idx at position after ) 
            </summary>
            <param name="data"></param>
            <param name="tokens"></param>
            <param name="idx"></param>
            <param name="idx_max"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.find_next_statement(NSS.Blast.Compiler.IBlastCompilationData,System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}},System.Int32@,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            scan token tree and find start and end index of next statement in token list
            </summary>
            <param name="data"></param>
            <param name="tokens"></param>
            <param name="idx">current index into token list</param>
            <param name="idx_max"></param>
            <param name="i1">start index of next statement</param>
            <param name="i2">end index of next statement</param>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.scan_and_parse_numeric(NSS.Blast.Compiler.IBlastCompilationData,System.Int32@,System.Int32@)">
            <summary>
            scan and parse a numeric from the token list in the form:
            
            -100.23
            
            </summary>
            <param name="data"></param>
            <param name="idx">indext to start scan from, on success wil be at position after last token of identifier</param>
            <param name="idx_max">the max index to scan into</param>
            <returns>null on failure, a node with the value on success</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.scan_and_parse_identifier(NSS.Blast.Compiler.IBlastCompilationData,System.Int32@,System.Int32@,System.Boolean)">
            <summary>
            scan input from idx building up 1 identifier as we go, after returning a valid node 
            the scan index will be on the token directly after the identifier 
            </summary>
            <param name="data"></param>
            <param name="idx">the index starting the scan from and the must be on the first token of the identifier to parse. on succes it will be on the token directly after the identifier</param>
            <param name="idx_max">the max index to scan into (max including)</param>
            <param name="add_minus"></param>
            <returns>null on errors, a valid node on success
            - can return nodes: function() and identifier[34].x
            </returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.NegateNodeInCompound(System.Boolean,NSS.Blast.Compiler.node)">
            <summary>
            if minus:
            - insert a parent compound: parent.function => parent.compound.function 
            - insert sibling with substract opcode
            </summary>
            <param name="minus"></param>
            <param name="n_function"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.scan_and_parse_function(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.BlastScriptFunction,System.Int32@,System.Int32@)">
            <summary>
            scan and parse out the next function. 
            
             function;
             function();
             function(function(a, b), c); 
             function(function(a, b)[2].x, c); 
            
            </summary>
            <param name="data">general compiler data</param>
            <param name="function">function to parse</param>
            <param name="idx">idx, starting at function, ending directly after</param>
            <param name="idx_max">max index to scan into</param>
            <returns>a node containing the function or null on failure</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.scan_and_parse_function(NSS.Blast.Compiler.IBlastCompilationData,System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}},NSS.Blast.Compiler.BlastScriptInlineFunction,System.Int32@,System.Int32@)">
            <summary>
            scan an inlined function 
            </summary>
            <param name="data"></param>
            <param name="tokens"></param>
            <param name="function"></param>
            <param name="idx"></param>
            <param name="idx_max"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.parse_sequence(NSS.Blast.Compiler.IBlastCompilationData,System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}},System.Int32@,System.Int32@,System.Boolean)">
            <summary>
            parse a sequence of tokens between () into a list of nodes 
            
            -> start with idx on the ( of the enclosing compound 
            
            </summary>
            <param name="data"></param>
            <param name="tokens">tokens to index, can be a slice of data.Tokens</param>
            <param name="idx">index directly after the opening ( or at first token of sequence within () </param>
            <param name="idx_max"></param>
            <param name="as_parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.grow_index_chain(NSS.Blast.Compiler.IBlastCompilationData,System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}},NSS.Blast.Compiler.node,System.Int32@,System.Int32@)">
            <summary>
            grow a chain of indices after some other node/token
            </summary>
            <param name="data"></param>
            <param name="chain_root">node to index</param>
            <param name="idx">token index to start reading chain from</param>
            <param name="idx_max">max index to grow into</param>
            <returns>chain root node with chain as children, or null on failure</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.check_if_assignment_node(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node,System.Boolean)">
            <summary>
            check if the node is an assignment 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.parse_statements(NSS.Blast.Compiler.IBlastCompilationData,System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}},NSS.Blast.Compiler.node,System.Int32,System.Int32)">
            <summary>
            parse a statement list
            - depending on defines this may execute multithreaded 
            </summary>
            <param name="data"></param>
            <param name="tokens"></param>
            <param name="parent">the parent node</param>
            <param name="idx_start">starting index into tokens </param>
            <param name="idx_max">max index in tokens to scan into</param>
            <returns>exitcode - blasterror</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.IsParsingInlineFunction(NSS.Blast.Compiler.IBlastCompilationData,System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}})">
            <summary>
            check if the stream we are parsing is an inlined function 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.ParseInlineFunction(NSS.Blast.Compiler.IBlastCompilationData,System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}})">
            <summary>
            parse a single inlined function from the tokens
            </summary>
            <param name="data">compilerdata</param>
            <param name="ftokens">the tokens defining the function</param>
            <returns>success if all went ok, errorcodes otherwise</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.FindAndExtractFunctionRoots(NSS.Blast.Compiler.IBlastCompilationData,System.Collections.Generic.List{System.Collections.Generic.List{System.Tuple{NSS.Blast.BlastScriptToken,System.String}}}@)">
            <summary>
            scan for functions and parse them into seperate nodes 
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastParser.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            execute the parser stage:
            - parse tokens into node tree
            - map identifiers (indexers, functions, constants) 
            </summary>
            <param name="data">compilation data</param>
            <returns>exitcode, 0 == success</returns>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastTokenizer">
            <summary>
            The Tokenizer:
            
            - splits input into list of tokens and identifiers 
            - splits out: comments, defines and validations (all stuff starting with # until eol)
            
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastTokenizer.Version">
            <summary>
            version
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastTokenizer.StageType">
            <summary>
            Tokenizer -> converts input text into array of tokens 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTokenizer.parse_token(System.Char)">
            <summary>
            classify char as token, default to identifier 
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTokenizer.scan_to_comment_end(System.String,System.Int32)">
            <summary>
            read past eol 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTokenizer.is_whitespace(System.Char)">
            <summary>
            classify char as whitespace: space, tabs, cr/lf, , (comma)
            </summary>
            <param name="ch"></param>
            <returns>true if a whitespace character</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTokenizer.is_token(System.Char)">
            <summary>
            check if char is a defined script token
            </summary>
            <returns>true if a token</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTokenizer.read_input_output_mapping(NSS.Blast.Compiler.IBlastCompilationData,System.String,System.String[],System.Boolean)">
            <summary>
            read #input and #output defines 
            </summary>
            <param name="data"></param>
            <param name="comment"></param>
            <param name="a"></param>
            <param name="is_input"></param>
            <returns>null on failure (also logs error in data)</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTokenizer.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            Execute the tokenizer stage
            </summary>
            <param name="data">compilation data</param>
            <returns>success if ok, otherwise an errorcode</returns>
        </member>
        <member name="T:NSS.Blast.Compiler.Stage.BlastTransform">
            <summary>
            Transform higher level constructs into their simpler constituents,
            [while, for, switch] into ifthen sequences 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastTransform.Version">
            <summary>
            current version 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.Stage.BlastTransform.StageType">
            <summary>
            transform stage 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTransform.clone_nodes(System.Collections.Generic.IEnumerable{NSS.Blast.Compiler.node})">
            <summary>
            make a deepclone of the list of nodes 
            </summary>
            <param name="nodes">input list to clone</param>
            <returns>yields each cloned node</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTransform.transform_switch(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            transform a switch into a series of ifthen statements 
            </summary>
            <param name="data"></param>
            <param name="n_switch">the node containing the switch statement</param>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTransform.transform_for(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            transform a for loop into a while statement 
            </summary>
            <param name="data">compilation data holding the ast</param>
            <param name="n_for">the node with the for loop</param>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTransform.transform_inline_function_call(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            transform a function call to an inlined funtion into the code it generates 
            </summary>
            <param name="data"></param>
            <param name="n"></param>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTransform.ClassifyIndexer(NSS.Blast.Compiler.node,NSS.Blast.blast_operation@,System.Byte@)">
            <summary>
            classify the indexers on a node
            </summary>
            <remarks>
            
            !!!! currently supports the following indexes only:
            
            .[x|y|z|w]
            .[r|g|b|a]
            
            </remarks>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTransform.transform_indexer(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            only call this on nodes that actually have an indexer, for now create functions 
            for indices, we could allow the interpretor to directly index it but then we would
            lose all debugging features (we would get invalid metadata types on indexing it,
            because we index a f4 for example expecting a f1 back, the interpretor has no knowledge 
            of indexers and for now i'd like to keep it like that)
            </summary>
            <param name="data"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTransform.transform_indexers(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            find and transform all indexers
            </summary>
            <param name="data"></param>
            <param name="ast_root"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTransform.transform(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.Compiler.node)">
            <summary>
            run transform depending on nodetype 
            - TODO -> would be nice if this all returned errors.. 
            </summary>
            <param name="data"></param>
            <param name="n"></param>
        </member>
        <member name="M:NSS.Blast.Compiler.Stage.BlastTransform.Execute(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            execute the transform stage:
            - merge compounds
            - transform for loops => while
            - transform switch => ifthen 
            - transfrom inlined functions 
            - transform indexers
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:NSS.Blast.Compiler.BlastCompiler">
             <summary>
             Blast Compiler 
             
             Compile scripts into bytecode, the process consists of several stages:
             
             
             For bytecode these stages might be executed:
             
             1   - tokenize:            convert code into a list of tokens 
             2   - parse:               parse list of tokens into a tree of nodes 
             2.1 - variable mapping     map all identifiers
             3   - transform:           transform nodes sequences  
             4.1 - analyse parameters:  determine parameter types and check inputs and outputs
             4.2 - analyse:             analyse nodes, reorder were needed, optimize for execution
             5   - flatten:             flatten execution path
             6   - node optimizer:      optimize nodes 
             7   - compile:             generate bytecode from the internal representation 
             8   - optimize bytecode:   optimize bytecode patterns 
             9   - package:             package bytecode and set it up for execution 
             
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastCompiler.opt_value">
            <summary>
            from this opcode until opt_ident constant values are encoded
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastCompiler.opt_ident">
            <summary>
            form this opcode until 255 variables are encoded
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastCompiler.ByteCodeStages">
            <summary>
            Default compilation setup 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastCompiler.HPCStages">
            <summary>
            compilation stages for compilation into a job,
            - use the same precompilation, make sure behaviour is equal even if some unknown bug is there
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastCompiler.CSStages">
            <summary>
            C# compilation uses the output from the hpc stage
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.BlastCompiler.Validate(NSS.Blast.Compiler.IBlastCompilationData,System.IntPtr)">
            <summary>
            Validate output using data set in script for NULL inputs 
            </summary>
            <param name="result">bytecode compiler data</param>
            <param name="blast">blast engine data</param>
            <returns>true if validation succeeded</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.BlastCompiler.EstimateStackSize(NSS.Blast.Compiler.CompilationData)">
            <summary>
            estimate stack size by running script with a selection of parameters from
            input, output and validation settings 
            
            TODO: EstimateStackSize and Validate should be combined 
            </summary>
            <returns>estimated stack size in bytes</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.BlastCompiler.PackageNormal(NSS.Blast.Compiler.CompilationData,System.Int32,System.Int32,System.Int32,System.Int32,NSS.Blast.BlastPackageFlags)">
            <summary>
            Package in normal mode. 
            
            - packagemode       = NORMAL
            - languageversion   = BS1
            </summary>
            <param name="cdata">Compiler data</param>
            <param name="code_size">size of code in bytes</param>
            <param name="metadata_size">size of metadata in bytes, 1 byte per data element in data and stack segment combined</param>
            <param name="data_size">size of datasegment in bytes</param>
            <param name="stack_size">size of stacksegement in bytes</param>
            <param name="flags">flags: alignment, stack</param>
            <returns>blast package data</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.BlastCompiler.PackageSSMD(NSS.Blast.Compiler.CompilationData,System.Int32,System.Int32,System.Int32,System.Int32,NSS.Blast.BlastPackageFlags)">
            <summary>
            package for ssmd use:  [code-metadata] [data-stack]
            </summary>
            <param name="cdata">compiler result data</param>
            <param name="code_size"></param>
            <param name="metadata_size"></param>
            <param name="data_size"></param>
            <param name="stack_size"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.BlastCompiler.Package(NSS.Blast.Compiler.IBlastCompilationData,NSS.Blast.BlastCompilerOptions)">
            <summary>
            package the result of the compiler into an executable package 
            </summary>
            <returns>the native blast package data structure</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.BlastCompiler.Compile(NSS.Blast.BlastEngineDataPtr,System.String,NSS.Blast.BlastCompilerOptions)">
            <summary>
            Compile script from text
            </summary>
            <param name="blast">blast engine data</param>
            <param name="code">the code</param>
            <param name="options">compiler options</param>
            <returns>compiler data</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.BlastCompiler.Compile(NSS.Blast.BlastEngineDataPtr,NSS.Blast.BlastScript,NSS.Blast.BlastCompilerOptions)">
            <summary>
            Compile a script
            </summary>
            <param name="blast">blast engine data</param>
            <param name="script">the script to compile</param>
            <param name="options">compileoptions</param>
            <returns>compiler data</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.BlastCompiler.CompileHPC(NSS.Blast.BlastEngineDataPtr,NSS.Blast.BlastScript,NSS.Blast.BlastCompilerOptions)">
            <summary>
            
            </summary>
            <param name="blast"></param>
            <param name="script"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.BlastCompiler.CompileCS(NSS.Blast.BlastEngineDataPtr,NSS.Blast.BlastScript,NSS.Blast.BlastCompilerOptions)">
            <summary>
            Compile using .net c# compiler 
            - only on windows .net framework > 4.5 
            </summary>
            <param name="blast"></param>
            <param name="script"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.BlastCompiler.CompilePackage(NSS.Blast.BlastEngineDataPtr,NSS.Blast.BlastScript,NSS.Blast.BlastCompilerOptions)">
            <summary>
            compile script into a managed blastscriptpackage containing blastpackagedata
            </summary>
            <param name="blast"></param>
            <param name="script"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.BlastCompiler.CompileDataPackage(NSS.Blast.BlastEngineDataPtr,NSS.Blast.BlastScript,NSS.Blast.BlastCompilerOptions)">
            <summary>
            Compile the script into a native blastscript datapackage
            </summary>
            <param name="blast"></param>
            <param name="script"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="T:NSS.Blast.Compiler.nodetype">
            <summary>
            the different nodetypes used in the ast
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.none">
            <summary>
            nodetype is not set
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.root">
            <summary>
            this is the root node
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.function">
            <summary>
            this node represents a function
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.assignment">
            <summary>
            this node represents an assignment to identifier
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.parameter">
            <summary>
            node represents a parameter to a function or sequence with identifier name/value
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.index">
            <summary>
            BS2 parameter indexer, .[] 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.operation">
            <summary>
            node represents an operation: +-/ etc.
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.yield">
            <summary>
            yield operation, must be in root
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.compound">
            <summary>
            represents a compound: ( () )
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.ifthenelse">
            <summary>
            the root of an if then else structure
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.ifthen">
            <summary>
            the ifthen clausule
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.ifelse">
            <summary>
            the ifelse clausule
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.condition">
            <summary>
            a condition, either in if statements or while/for loops 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.whileloop">
            <summary>
            the root of a while loop
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.whilecompound">
            <summary>
            the while loop body, handled as a compound 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.switchnode">
            <summary>
            the switch statement root node, transformed into ifthenelse statements during compilation
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.switchcase">
            <summary>
            a switch case 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.switchdefault">
            <summary>
            the default case 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.forloop">
            <summary>
            the root of a for loop 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.jump_to">
            <summary>
            a jump instruction inserted by the compiler that jumps to a given label in the ast
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.label">
            <summary>
            a label (a jump target) inserted by the compiler 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.nodetype.inline_function">
            <summary>
            an inline function defined in script 
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.node">
            <summary>
            an ast node used by the blast compiler
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.parent">
            <summary>
            the parent node, null if the node is the root
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.type">
            <summary>
            nodetype of node
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.function">
            <summary>
            if the node is a function then its this one
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.token">
            <summary>
            any token attached to this node 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.identifier">
            <summary>
            any identifier attached to this node
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.variable">
            <summary>
            variable data inferred from the ast and connected to the nodes identifier 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.children">
            <summary>
            children of node 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.depends_on">
            <summary>
            dependencies of node 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.indexers">
            <summary>
            BS2: indexers, arrays and compound types []. 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.constant_op">
            <summary>
            any operation connected to this node (type == function | operation | parameter (pop))
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.skip_compilation">
            <summary>
            skip general compilation of this node, some nodes control when to compile their own dependencies like initializers in loops
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.is_constant">
            <summary>
            true if the node represents a constant value 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.vector_size">
            <summary>
            the vector size 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.is_vector">
            <summary>
            true if the value represented is a vector, dont use this directly as the compilers interpretation might change during the process. 
            check variable or function property instead to find out if something is a vector 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.linked_push">
            <summary>
            internal use: a linked push operation, used during compilation to keep track of pushpop pairs
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.node.linked_pop">
            <summary>
            internal use: a linked pop operation, used during compilation to keep track of pushpop pairs
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.IsRoot">
            <summary>
            Only true if this is the root of the ast
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.IsCompound">
            <summary>
            True if this a compound node
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.IsAssignment">
            <summary>
            True if this is an assignment
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.IsFunction">
            <summary>
            True if this is a function 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.IsStackFunction">
            <summary>
            true if the function maps to a stack operation: push, pop etc. 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.IsPushFunction">
            <summary>
            True if this is a function pushing to the stack 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.IsPopFunction">
            <summary>
            True if this is a function popping from the stack
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.IsInlinedFunction">
            <summary>
            True if this node represents an inlined function 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.IsInlinedFunctionCall">
            <summary>
            returns true if this is a function that maps to an inlined function and NOT to an api function 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.IsOperation">
            <summary>
            True if this is an operation 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.IsLeaf">
            <summary>
            True if this is a leaf nod
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.IsVector">
            <summary>
            True if this is data with a cardinality larger then 1 (a vector) 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.IsScriptVariable">
            <summary>
            True if this node represents a scripted variable 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.HasDependencies">
            <summary>
            true if the node has dependencies
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.DependencyCount">
            <summary>
            get the number of dependency nodes
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.HasChildren">
            <summary>
            true if the node contains child nodes 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.HasOneChild">
            <summary>
            true if the node has exactly 1 node
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.HasIndexers">
            <summary>
            true if node contains indexers 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.HasIdentifier">
            <summary>
            true if node is represented by an identifier 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.node.CountNodes">
            <summary>
            get the total number of nodes in the tree as seen from current node
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.node.CountChildNodes(NSS.Blast.Compiler.node)">
            <summary>
            get the total number of nodes in the children of n
            </summary>
            <param name="n">the node to count all child nodes of</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsVectorDefinition(NSS.Blast.Compiler.node)">
            <summary>
            check if a node equals a vector definition: 
            
            ->  ( 1 2 3 ) -> compound[3] ( id id id ) 
                          -> compound[n] ( n[pop | identifier[1]] ) 
            
            -> root node == compound with n children representing its elements 
            
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.CreateConstantParameter(NSS.Blast.blast_operation)">
            <summary>
            create a constant value parameter from operation 
            </summary>
            <param name="value_0">the value to insert</param>
            <returns>the newly created paramater node with a constant value set</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsNonNestedVectorDefinition">
            <summary>
            check if this node is a definition of a vector that does not nest:
            (1 1 1 1) 
            (1 pop pop) 
            (2 maxa(1) 2 3)
            (3, -1 2 2) =>  (3 (-1) 2 2)
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsNonNestedVectorDefinition(NSS.Blast.Compiler.node)">
            <summary>
            check if given node contains a non nested vector define: node = (1 2 3 4)  | node = (1 2 (-3) 4)
            </summary>
            <param name="n">the node to check</param>
            <returns>true if it does</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.FirstConsecutiveOperationSequence(NSS.Blast.Compiler.node,System.Int32,System.Int32,NSS.Blast.blast_operation@,System.Int32@,NSS.Blast.Compiler.node@)">
            <summary>
            get the largest group of operations of the same type 
            </summary>
            <param name="node">the parent node of the operation list</param>
            <param name="min_group_size">minimal group size</param>
            <param name="from">start check from this node</param>
            <param name="op">outputs operation of largest group or nop</param>
            <param name="op_count">nr of operations in group</param>
            <param name="first_op_in_sequence"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.FirstConsecutiveOperationSequence(System.Int32,System.Int32,NSS.Blast.blast_operation@,System.Int32@,NSS.Blast.Compiler.node@)">
            <summary>
            scan children of node for the first group of operations of a given minimal size 
            </summary>
            <param name="min_groupsize">the minimal group size</param>
            <param name="from">start check from this node</param>
            <param name="op">operation to scan for</param>
            <param name="op_count">the operation count in the group found</param>
            <param name="first_op_in_sequence">first operation found in sequence</param>
            <returns></returns>
        </member>
        <member name="P:NSS.Blast.Compiler.node.IsFloat">
            <summary>
            interpret this node as a float value and return that
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.AsFloat">
            <summary>
            interpret the node's attached identifier as a floating point value, returns Blast.InvalidNumeric if it could
            not parse the identifier as a numeric
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.node.#ctor(NSS.Blast.Compiler.node,NSS.Blast.Compiler.node[])">
            <summary>
            general constructor
            </summary>
            <param name="_parent">parent node</param>
            <param name="_children">child nodes</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.#ctor(NSS.Blast.Compiler.nodetype,NSS.Blast.BlastScriptToken)">
            <summary>
            general constructor
            </summary>
            <param name="_type">the nodetype</param>
            <param name="_token">the attached token</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.ToString">
            <summary>
            provides information in debug display through a tostring overload
            </summary>
            <returns>node formatted as string</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.GetNodeDescription">
            <summary>
            get a textual description of this node 
            </summary>
            <returns>the text description</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.ToNodeTreeString(System.Int32)">
            <summary>
            generate a multiline string representing the node tree structure
            </summary>
            <param name="indentation">nr of space to indent for each child iteration</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.ToNodeTreeString(NSS.Blast.Compiler.node,System.Text.StringBuilder,System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <param name="sb"></param>
            <param name="indent"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsOperationList">
            <summary>
            check if the node is an operation sequence in the form: 3 + a + 4 + 4 + max(3093) + (4 + 0) 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsSingleOperationList(NSS.Blast.blast_operation@)">
            <summary>
            check if this node contains an operation sequence with only 1 different operator:
            a = 1 * 3 * 3 * 4; 
            </summary>
            <returns>true if an operation list and all operations used are the same</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsCompoundWithSingleNegationOfValue">
            <summary>
            check if the node IS:
            [compound][-][param|pop_or_val][/compound]
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsCompoundWithSingleNegationOfValue(NSS.Blast.Compiler.node)">
            <summary>
            check if the node IS:
            [compound][-][param|pop_or_val][/compound]
            </summary>
            <param name="node">the node that should be the compound in the check</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsOperationList(NSS.Blast.Compiler.node)">
            <summary>
            check if the node is an operation sequence in the form: 3 + a + 4 + 4 + max(3093) + (4 + 0) 
            </summary>
            <param name="node">the node to check</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsOperationList(NSS.Blast.Compiler.node,NSS.Blast.blast_operation@)">
            <summary>
            check if the node is an operation sequence in the form: 3 + a + 4 + 4 + max(3093) + (4 + 0) 
            </summary>
            <param name="node">the node to check</param>
            <param name="singleop">the operation found, if single it maps to the operation, if none its nop, on many different it will be op.ex</param>
            <returns>true if a list of operations</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.encode44(NSS.Blast.Compiler.node)">
            <summary>
            -encode vectorsize in lower nibble
            -encode childcount == parametercount in high nibble 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.node.encode44(NSS.Blast.Compiler.node,System.Byte)">
            <summary>
            -encode vectorsize in lower nibble
            -encode parametercount in high nibble 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.node.SetDependency(NSS.Blast.Compiler.node)">
            <summary>
            set a dependency for this node, some constructs such as loops use this for the initializer
            </summary>
            <param name="ast_node">the node to add to dependencies</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.InsertDependency(NSS.Blast.Compiler.node)">
            <summary>
            insert (actually it appends) a depenency, updateing parent and chldren list 
            </summary>
            <param name="ast_node">the node to append</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.AppendDependency(NSS.Blast.Compiler.node)">
            <summary>
            add a node to the list of nodes to depend on, these are tobe inserted before 
            this node during compilation, the parent of the node is updated to this
            </summary>
            <param name="n">the node to add</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.AppendDependencies(System.Collections.Generic.IEnumerable{NSS.Blast.Compiler.node})">
            <summary>
            append multiple dependant nodes
            </summary>
            <param name="nodes">nodes to add to dependencies</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.GetChild(NSS.Blast.Compiler.nodetype)">
            <summary>
            get the first child found of a given nodetype
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.node.GetChild(NSS.Blast.Compiler.nodetype,NSS.Blast.Compiler.nodetype)">
            <summary>
            get first child matching first choice, if none found, try the second choice
            </summary>
            <param name="first_choice">first to try to locate</param>
            <param name="second_choice">next attemt to locate</param>
            <returns>a node if any was found, otherwise null</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.GetChildren(NSS.Blast.Compiler.nodetype)">
            <summary>
            get children of given nodetype
            </summary>
            <returns>an array of nodes</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.GetOtherChildren(NSS.Blast.Compiler.nodetype)">
            <summary>
            get child nodes not of the type t
            </summary>
            <param name="t">the nodetype to discriminate</param>
            <returns>an array of nodes</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.CountOtherChildren(NSS.Blast.Compiler.nodetype)">
            <summary>
            count nr of childnodes with not nodetype t
            </summary>
            <returns>number of children not matching nodetype t</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.CountChildren(NSS.Blast.Compiler.nodetype)">
            <summary>
            count children of given nodetype 
            </summary>
            <returns>number of children matching type t</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.DeepClone(System.Boolean)">
            <summary>
            deep clones node without root parent set
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.GetLeafNodes">
            <summary>
            get all leaf nodes from this node
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.GetLeafNodes(System.Collections.Generic.List{NSS.Blast.Compiler.node},NSS.Blast.Compiler.node)">
            <summary>
            gather all leaf nodes from a given node
            </summary>
            <param name="leafs">leaf node list to use</param>
            <param name="n">node to gather leafs from</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.HasSingleCompoundAsChild">
            <summary>
            check if we have 1 child and that it is a compounded statement list
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.CheckIfFunctionIsUsedInTree(NSS.Blast.blast_operation)">
            <summary>
            check if a given function is used in this node or its children
            </summary>
            <param name="op">the op representing the function</param>
            <returns>true if used</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.ReduceSingularCompounds(NSS.Blast.Compiler.node)">
            <summary>
            recursively reduces unneeded compound nesting 
            (((2 3))) => (2 2)
            </summary>
            <param name="node">the root node of the nested compound</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.CreatePopNode(NSS.Blast.BlastEngineDataPtr,NSS.Blast.Compiler.node)">
            <summary>
            create a pop node based on the information pushed, links the push and pop together 
            </summary>
            <param name="blast">current engine data</param>
            <param name="related_push">the earlier push op</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.CreatePushNode(NSS.Blast.BlastEngineDataPtr,NSS.Blast.Compiler.node)">
            <summary>
            create a push node with the information from the given node, THIS DOES NOT ADD THAT NODE AS CHILD
            </summary>
            <param name="blast">blast engine data</param>
            <param name="topush">node to push</param>
            <returns>returns the pushing node</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsFlatParameterList(System.Collections.Generic.IEnumerable{NSS.Blast.Compiler.node})">
            <summary>
            check if the list of given nodes is flat 
            - no nested things
            - no function calls ?? might want to be looser here... todo
            </summary>
            <param name="nodes">node list to check</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsSimplexVectorDefinition">
            <summary>
            check if the node defines a vector in a 'simple' way: no nesting, assumes vector-sizes in ast are set 
            <remarks>
            Performs a check on a node that only returns true if the node is marked as vector by analysis
            and its code is completely flattened, the vector elements must be a direct child of the node being 
            checked, there may be no compound in between as that should have been removed by the flatten operation
            
            Targets: 
            
            <code>
            a = (1 2); 
            a = (1 pop 2);
            a = (a 2 pop 3);
            </code>
            
            It also matches vectors of differing sizes but the vector component count of the parameters/childnodes
            must equal the vectorsize of the assignee
            <code>
            a = (a 2 pop2);   
            </code>
            </remarks>
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsFlat(System.Boolean)">
            <summary>
            check if the node is a flat node                       
            - contains NO compounds 
            - contains no object with children other then a function
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.GetMaximumTreeDepth(System.Int32)">
            <summary>
            get maximum depth of node tree starting from this node 
            </summary>
            <param name="depth">depth from this node until deepest leaf</param>
            <returns>depth from this node until deepest leaf</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.GetMaximumTreeDepth">
            <summary>
            get maximum depth of node tree starting from this node 
            </summary>
            <returns>depth from this node until deepest leaf</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.SetChild(NSS.Blast.Compiler.node)">
            <summary>
            set a node to be a child of this node (appends to end of child list),
            updates the parent of the node and removes it from its possible previous parent
            </summary>
            <param name="ast_node">the node to set as child is returned</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.SetChild(NSS.Blast.Compiler.node,System.Int32)">
            <summary>
            set a node to be a child of this node (appends to end of child list),
            updates the parent of the node and removes it from its possible previous parent
            </summary>
            <param name="ast_node">the node to set as child is returned</param>
            <param name="index">index to insert at at parent</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.SetChildren(System.Collections.Generic.IEnumerable{NSS.Blast.Compiler.node})">
            <summary>
            set a list of nodes a children to this node
            </summary>
            <param name="nodes">the nodes to set as child</param>
            <returns>this node</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.CreateChild(NSS.Blast.Compiler.nodetype,NSS.Blast.BlastScriptToken,System.String)">
            <summary>
            create a new node as a child of this node and returns the newly created node 
            </summary>
            <param name="type">nodetype to create</param>
            <param name="token">token to set</param>
            <param name="identifier">identifier used</param>
            <returns>the newly created node </returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.CreateChild(NSS.Blast.Compiler.nodetype,NSS.Blast.BlastScriptToken,System.String,System.Int32)">
            <summary>
            create a new node as a child of this node and returns the newly created node 
            </summary>
            <param name="type">nodetype to create</param>
            <param name="token">token to set</param>
            <param name="identifier">identifier used</param>
            <param name="index">index at which to insert node</param>
            <returns>the newly created node </returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.AppendIndexer(NSS.Blast.BlastScriptToken,System.String)">
            <summary>
            add an indexer to this node
            </summary>
            <param name="token"></param>
            <param name="identifier"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.CountChildType(NSS.Blast.Compiler.nodetype)">
            <summary>
            count child nodes of the given type
            </summary>
            <param name="type">the nodetype to count</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.CountChildType(NSS.Blast.Compiler.nodetype,NSS.Blast.Compiler.nodetype)">
            <summary>
            count all children matching one of 2 types 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.ChildCount">
            <summary>
            number of child nodes below this node
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.FirstChild">
            <summary>
            first child of node, null if there are no children
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.node.LastChild">
            <summary>
            last child of node, null if there are no children, equals first if childcount == 1
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.node.CheckIfCouldBeVectorList">
            check if a node is a vector, its children should all be
            - identifiers
            - functions
            - compounds ( todo -> should validate if they result in a single number.... )
        </member>
        <member name="M:NSS.Blast.Compiler.node.InsertBeforeThisNodeInParent(NSS.Blast.Compiler.nodetype,NSS.Blast.BlastScriptToken)">
            <summary>
            insert a new node of the given type and operation  before this node in parent 
            </summary>
            <param name="type">node type</param>
            <param name="token">token for script operation</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.InsertChild(System.Int32,NSS.Blast.Compiler.node)">
            <summary>
            insert a child not at given index 
            - removes new child from old parent
            - set new childs parent to this node
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.node.InsertParent(NSS.Blast.Compiler.node)">
            <summary>
            insert a node as new parent to this node => before: Parent.Child, after: Parent.NewNode.Child
            </summary>
            <param name="node">the node to insert/replace as a new parent</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.GetConstantFloatValue(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            get the constant float value encoded by the variable 
            - float: vector size is checked and errors will be logged if incorrect 
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.GetConstantFloat4Value(NSS.Blast.Compiler.IBlastCompilationData)">
            <summary>
            get the constant float4 value encoded by the variable 
            - float4: vector size is checked and errors will be logged if incorrect 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.node.GenerateUniqueId(System.String)">
            <summary>
            generate a unique id based on a guid 
            </summary>
            <param name="tag">name to use for reference while debugging</param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.EnsureIdentifierIsUniquelySet(System.String)">
            <summary>
            make sure the identifier is set to a UniqueID  
            if it is not set a new id is generated
            </summary>
            <param name="tag">name to use for reference while debugging</param>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsSingleValueOrPop">
            <summary>
            determine if the node is a single value or a pop operation
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsSingleValueOrPop(NSS.Blast.Compiler.node)">
            <summary>
            determine if the node is a single value or a pop operation
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.node.HasInlineFunction(System.String)">
            <summary>
            check if there is a function in the ast root with the given identifier as name 
            </summary>
            <param name="identifier">name of function</param>
            <returns>if a function with that name exists</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.IsRootedIn(NSS.Blast.Compiler.nodetype)">
            <summary>
            check if the node has a parent of the given type, checks all nodes until reaching root  
            </summary>
            <param name="type">the type to find a parent for</param>
            <returns>true if the node has a parent with the given type</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.node.SkipCompilation">
            <summary>
            skip compiling this node 
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.NodeListCache">
            <summary>
            a node list cache, trashes the gc a little less using this, 
            only caches small lists, 1 for each thread using this
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.NodeListCache.Acquire(System.Int32)">
            <summary>
            get a new list of desired capacity
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.NodeListCache.Release(System.Collections.Generic.List{NSS.Blast.Compiler.node})">
            <summary>
            release the nodelist back to the static cache
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:NSS.Blast.Compiler.NodeListCache.ReleaseArray(System.Collections.Generic.List{NSS.Blast.Compiler.node})">
            <summary>
            release the list and return its contents in an array
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.NodeListExtensions">
            <summary>
            provide some extensions on list, using list as stack we hit the cache more
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.NodeListExtensions.Push(System.Collections.Generic.List{NSS.Blast.Compiler.node},NSS.Blast.Compiler.node)">
            <summary>
            push a node to the end of the list 
            </summary>
            <param name="list"></param>
            <param name="node"></param>
        </member>
        <member name="M:NSS.Blast.Compiler.NodeListExtensions.PushRange(System.Collections.Generic.List{NSS.Blast.Compiler.node},System.Collections.Generic.IEnumerable{NSS.Blast.Compiler.node})">
            <summary>
            push a list of nodes to the end of the list 
            - this reverses the input node order befor adding them to the end to preserve pop order
            </summary>
            <param name="list"></param>
            <param name="nodes"></param>
        </member>
        <member name="M:NSS.Blast.Compiler.NodeListExtensions.TryPop(System.Collections.Generic.List{NSS.Blast.Compiler.node},NSS.Blast.Compiler.node@)">
            <summary>
            try to pop a node from the end of the list 
            </summary>
            <param name="list"></param>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="T:NSS.Blast.Compiler.IBlastCompilationData">
            <summary>
            interface into compilationdata, we should restrict outside use a bit via this 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.Version">
            <summary>
            compiler version 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.Blast">
            <summary>
            blast engine data used in this compilation
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.Script">
            <summary>
            the script 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.CompilerOptions">
            <summary>
            Compiler Options used during compilation
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.AST">
            <summary>
            Compiler node tree
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.Tokens">
            <summary>
            List of tokens as parsed from the input
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.Variables">
            <summary>
            List of variables as found in input
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.Offsets">
            <summary>
            Offsets into the datasegment for variable indices 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.Jumps">
            <summary>
            Jumps found in the script 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.Defines">
            <summary>
            Compiler defines used during compilation, this contains only the unique defines set by this script
            and more defines might apply depending on the setup
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.Inputs">
            <summary>
            Defined Inputs 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.Outputs">
            <summary>
            Defined Outputs 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.Validations">
            <summary>
            Validations defined in script 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.IBlastCompilationData.LogError(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            log an error to the compiler log
            </summary>
            <param name="msg">the message to log</param>
            <param name="code">an error code</param>
            <param name="linenr">possibly the linenr</param>
            <param name="member">possibly the callername</param>
        </member>
        <member name="M:NSS.Blast.Compiler.IBlastCompilationData.LogTrace(System.String,System.Int32,System.String)">
            <summary>
            trace information, does nothing in release 
            </summary>
            <param name="msg">the message to log</param>
            <param name="linenr">possibly the linenr</param>
            <param name="member">possibly the callername</param>
        </member>
        <member name="M:NSS.Blast.Compiler.IBlastCompilationData.LogWarning(System.String,System.Int32,System.String)">
            <summary>
            log a warning to the compiler log
            </summary>
            <param name="msg">the message to log</param>
            <param name="linenr">possibly the linenr</param>
            <param name="member">possibly the callername</param>
        </member>
        <member name="M:NSS.Blast.Compiler.IBlastCompilationData.LogToDo(System.String,System.Int32,System.String)">
            <summary>
            log a message to the compiler log
            </summary>
            <param name="msg">the message to log</param>
            <param name="linenr">possibly the linenr</param>
            <param name="member">possibly the callername</param>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.IsOK">
            <summary>
            true if no errors are set in the compilation log and no errorcode is set
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.HasErrors">
            <summary>
            true if an errorcode is set or errors are present in the compilation log 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.CanValidate">
            <summary>
            true if the script can be validated (it contains validation defines) 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.HasDefines">
            <summary>
            true if the script defines compiler defines 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.HasInlinedFunctions">
            <summary>
            true if the script has functions inlined 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.IBlastCompilationData.GetVariable(System.String)">
            <summary>
            lookup a variablemapping defined by the script by its name
            </summary>
            <param name="name">the name of the variable as used in the script code</param>
            <returns>the variable if found, null otherwise</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.IBlastCompilationData.GetVariableFromOffset(System.Byte)">
            <summary>
            lookup a variable defined by script based on its offset 
            </summary>
            <param name="offset">the datasegment offset</param>
            <returns>the variable</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.IBlastCompilationData.TryGetDefine(System.String,System.String@)">
            <summary>
            attempt to get a defined value from script defined compilerdefines
            </summary>
            <param name="identifier">the identifier</param>
            <param name="defined_value">the output value</param>
            <returns>true if a define was found with the given name</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.IBlastCompilationData.ExistsVariable(System.String)">
            <summary>
            returns true if a variable exists with the given name
            </summary>
            <param name="name">variable name</param>
            <returns>true if the variable exists</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.IBlastCompilationData.ExistsInlineFunction(System.String)">
            <summary>
            checks if an inlined function with the given name|identifier exists 
            </summary>
            <param name="name">identifier name</param>
        </member>
        <member name="M:NSS.Blast.Compiler.IBlastCompilationData.HasInput(System.Int32)">
            <summary>
            check if there is an input defined by the script with the given id 
            </summary>
            <param name="id">the integer identifier</param>
            <returns>true if defined</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.IBlastCompilationData.HasInput(System.String)">
            <summary>
            check if there is an input defined by the script with the given id 
            </summary>
            <param name="name">the input variable name</param>
            <returns>true if defined</returns>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.HasVariables">
            <summary>
            true if the script defines variables 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.HasOffsets">
            <summary>
            true if the script defines variables 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.VariableCount">
            <summary>
            number of variables defined in the script 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.IBlastCompilationData.OffsetCount">
            <summary>
            number of variable offsets defined in the script
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.CompilationData">
            <summary>
            Data created during compilation and used for analysis, packaging and debugging/display purposes
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.CompilationData.version">
            <summary>
            Version
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.Version">
            <summary>
            Version
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.CompilationData.Message">
            <summary>
            a compiler message 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.CompilationData.CompilerMessages">
            <summary>
            List of messages issued during compilation 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.LogMessage(System.String,System.Int32,System.String)">
            <summary>
            on older .net versions we could get the stackframe 
            see: https://stackoverflow.com/questions/12556767/how-do-i-get-the-current-line-number
            and: https://stackoverflow.com/questions/38476796/how-to-set-net-core-in-if-statement-for-compilation
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.LogTrace(System.String,System.Int32,System.String)">
            <summary>
            Trace a message, does nothing in release builds 
            </summary>
            <param name="msg">the message to trace</param>
            <param name="linenr">line number</param>
            <param name="member">caller member name</param>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.LogError(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Log an error to the log, also writes to player log / debugstream
            </summary>
            <param name="msg">the message</param>
            <param name="code">optional errorcode</param>
            <param name="linenr">optional linenr</param>
            <param name="member">optional caller member name</param>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.LogWarning(System.String,System.Int32,System.String)">
            <summary>
            Log a warning to the log, also writes to player log / debugstream
            </summary>
            <param name="msg">the message</param>
            <param name="linenr">optional linenr</param>
            <param name="member">optional caller member name</param>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.LogToDo(System.String,System.Int32,System.String)">
            <summary>
            logs a todo, only in standalone debug builds 
            </summary>
            <param name="msg">the message</param>
            <param name="linenr">optional line number</param>
            <param name="member">optional caller member name</param>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.LastErrorMessage">
            <summary>
            keep reference of any last error message, voiding the need to search for it 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.LastError">
            <summary>
            returns the last error code or success if nothing went wrong 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.ErrorCount">
            <summary>
            number of errors that occured during compilation 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.HasErrors">
            <summary>
            number of errors that occured during compilation
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.WarningCount">
            <summary>
            number of warnings that occured during compilation 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.HasWarnings">
            <summary>
            true if any warning was logged during compilation
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.HasErrorsOrWarnings">
            <summary>
            true if any erorr or warning occured 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.HasInlinedFunctions">
            <summary>
            true if the script compiled defines inlined function macros 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.IsOK">
            <summary>
            true if everything went ok 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.#ctor(NSS.Blast.BlastEngineDataPtr,NSS.Blast.BlastScript,NSS.Blast.BlastCompilerOptions)">
            <summary>
            setup new compilation data
            </summary>
            <param name="blast">blast engine data</param>
            <param name="script">the script to compile</param>
            <param name="options">compiler options</param>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.Blast">
            <summary>
            blast engine data 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.Script">
            <summary>
            the input script 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.CompilationData.Executable">
            <summary>
            the intermediate 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.CompilerOptions">
            <summary>
            Options used during compilation 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.GetHumanReadableCode(System.Int32,System.Boolean)">
            <summary>
            this version has a little more information than the generic bytecode reader in blast due to having access to all compilation data
            </summary>
            <returns>a readable string</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.GetHumanReadableBytes(System.Int32,System.Boolean)">
            <summary>
            get a readable string from the compiled code
            </summary>
            <param name="columns">number of columns to use in the presentation of the bytes</param>
            <param name="index">true if you want an index (000| ) at the start of each line</param>
            <returns></returns>
        </member>
        <member name="F:NSS.Blast.Compiler.CompilationData.code">
            <summary>
            intermediate bytecode, only public for debugging view purposes, dont use, dont modify
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.AST">
            <summary>
            the rootnode of the abstract syntax tree
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.Variables">
            <summary>
            List of variables in script 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.ConstantVariables">
            <summary>
            List of constant variables (constant data needs to be somewhere)
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.Offsets">
            <summary>
            list of used variable offsets 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.Jumps">
            <summary>
            list of jumps 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.Defines">
            <summary>
            list of defines defined by this script 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.InlinedFunctions">
            <summary>
            functions found inlined 
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.Inputs">
            <summary>
            list of inputs defined by this script
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.Outputs">
            <summary>
            list of outputs defined by this script
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.Validations">
            <summary>
            list of validations defined by this script
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.CompilationData.Tokens">
            <summary>
            list of tokens as parsed out of the script
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.CreateVariable(System.String,System.Boolean,System.Boolean)">
            <summary>
            create a holder for variable data collected during compilation 
            - will log errors if the variable exists and returns null 
            - initializes reference count at 1
            </summary>
            <param name="name">first part of identifier - the name</param>
            <param name="is_input">true if used as an input</param>
            <param name="is_output">true if used as an output</param>
            <returns>null on failure, any error will be logged</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.TryGetVariable(System.String,NSS.Blast.BlastVariable@)">
            <summary>
            try to lookup a reference 
            - does not reference count 
            </summary>
            <param name="name">the name of the variable to lookup</param>
            <param name="variable">output variable</param>
            <returns>true if found</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.GetOrCreateVariable(System.String)">
            <summary>
            get or create a holder for variable data during compilation 
            - maintains reference count
            </summary>
            <param name="name">identifier name</param>
            <returns>null on failure</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.TryGetDefine(System.String,System.String@)">
            <summary>
            try to lookup define by identifier name
            </summary>
            <param name="identifier"></param>
            <param name="defined_value"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.TryGetInput(NSS.Blast.BlastVariable,NSS.Blast.BlastVariableMapping@)">
            <summary>
            Try to lookup a input variable mapping 
            </summary>
            <param name="v">the variable</param>
            <param name="mapping">output mapping</param>
            <returns>true if found</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.TryGetOutput(NSS.Blast.BlastVariable,NSS.Blast.BlastVariableMapping@)">
            <summary>
            try to lookup an output variable mapping
            </summary>
            <param name="v">the variable</param>
            <param name="mapping">the output variable mapping</param>
            <returns>true if found</returns>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.ExistsInlineFunction(System.String)">
            <summary>
            checks if an inlined function with the given name|identifier exists 
            </summary>
            <param name="name">identifier name</param>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.AddInlinedFunction(NSS.Blast.Compiler.BlastScriptInlineFunction)">
            <summary>
            add an inlined function 
            </summary>
            <param name="f"></param>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.GetInlinedFunction(System.String)">
            <summary>
            get an inlined function, returns null on fail
            </summary>
            <param name="name">the name if the function</param>
        </member>
        <member name="M:NSS.Blast.Compiler.CompilationData.TryGetInlinedFunction(System.String,NSS.Blast.Compiler.BlastScriptInlineFunction@)">
            <summary>
            try to lookup an inlined function by name 
            </summary>
            <param name="name"></param>
            <param name="inlined_function"></param>
            <returns></returns>
        </member>
        <member name="T:NSS.Blast.Compiler.CSCompilationData">
            <summary>
            compiler data for the C# compiler 
            - as it uses the output from hpc we base data on its data
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.CSCompilationData.Namespace">
            <summary>
            Target namespace for compiling scripts into
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.CSCompilationData.#ctor(NSS.Blast.BlastEngineDataPtr,NSS.Blast.BlastScript,NSS.Blast.BlastCompilerOptions)">
            <summary>
            Setup CS Compiler chain
            </summary>
            <param name="blast">blast engine data</param>
            <param name="script">script code</param>
            <param name="options">compiler options</param>
        </member>
        <member name="T:NSS.Blast.Compiler.BlastScriptInlineFunction">
            <summary>
            an inlined script function definition 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastScriptInlineFunction.Name">
            <summary>
            inlined function name
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastScriptInlineFunction.ParameterCount">
            <summary>
            parameter count as defined in script 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastScriptInlineFunction.Node">
            <summary>
            root node of function 
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.HPCCompilationData">
            <summary>
            compiler data for the hpc compiler 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.HPCCompilationData.HPCCode">
            <summary>
            resulting burstable C# code
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.HPCCompilationData.#ctor(NSS.Blast.BlastEngineDataPtr,NSS.Blast.BlastScript,NSS.Blast.BlastCompilerOptions)">
            <summary>
            setup compilation data for the HPC compiler chain
            </summary>
            <param name="blast">blast</param>
            <param name="script">the blast script to compile</param>
            <param name="options">blast compiler options</param>
        </member>
        <member name="T:NSS.Blast.Compiler.BlastIntermediate">
            <summary>
            intermediate bytecode data for use by compiler 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastIntermediate.data_capacity">
            <summary>
            nr of datapoints
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastIntermediate.code_capacity">
            <summary>
            max size of bytecode in bytes
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastIntermediate.data_element_bytesize">
            <summary>
            
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastIntermediate.Id">
            <summary>
            unique script id
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastIntermediate.code_size">
            <summary>
            size of code in bytes
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastIntermediate.code_pointer">
            <summary>
            index into bytecode, next point of execution, if == code_size then end of script is reached
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastIntermediate.data_count">
            <summary>
            offset into data after the last variable, from here the stack starts 
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastIntermediate.max_stack_size">
            <summary>
            maximum reached stack size in floats  
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastIntermediate.code">
            <summary>
            byte code compiled from script
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastIntermediate.data">
            <summary>
            input, output and scratch data fields
            </summary>
        </member>
        <member name="F:NSS.Blast.Compiler.BlastIntermediate.metadata">
            <summary>
             max 16n vectors up until (float4x4)   datasize = lower 4 bits + 1
             - otherwise its a pointer (FUTURE)      
             - datatype                              datatype = high 4 bits >> 4
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.BlastIntermediate.DataCount">
            <summary>
            nr of data elements (presumably 32bits so 4bytes/element) - same as data_offset, added for clarity
            </summary>
        </member>
        <member name="P:NSS.Blast.Compiler.BlastIntermediate.DataByteSize">
            <summary>
            data byte size 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.BlastIntermediate.GetDataSegmentElement(System.Int32@)">
            <summary>
            read a float from the datasegement at given element index
            </summary>
            <param name="data_segment_index">element index into data segment</param>
            <returns>the data </returns>
        </member>
        <member name="M:NSS.Blast.Compiler.BlastIntermediate.Validate(System.IntPtr@)">
            <summary>
            validate intermediate 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.BlastIntermediate.Execute(System.IntPtr@,System.Boolean)">
            <summary>
            execute the intermediate for validation and stack info 
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.JumpLabelType">
            <summary>
            jump label types, used for reference during compilation 
            </summary>
        </member>
        <member name="T:NSS.Blast.Compiler.IMJumpLabel">
            <summary>
            a jump label, for help keeping track of jump targets 
            </summary>
        </member>
        <member name="M:NSS.Blast.Compiler.IMJumpLabel.ToString">
            <summary>
            tostring override
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastCompilerOptions">
            <summary>
            Options for compiling and packaging scripts 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.Language">
            <summary>
            The languageversion to use for the output of the compilation. Packagemode and language version are coupled but there may be deviations:
            - You can execute BS1 language version files with SSMD package modes if you guarentee that the code doesnt branch (the interpretor wont check this)
            - You can exectue BS1SSMD compiled packages with the normal interpretor in normal package mode
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.PackageMode">
            <summary>
            the package mode for the output, this determines how code and data is organized in memory 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.PackageAllocator">
            <summary>
            Allocator for data package 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.AutoValidate">
            <summary>
            run validation if set in script 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.Optimize">
            <summary>
            run code optimizer 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.CompileWithSystemConstants">
            <summary>
            compile script using constant data fields 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.ConstantEpsilon">
            <summary>
            compare epsilon for constants, on fast float mode it wont match on float.epsilon
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.ConstantPrecision">
            <summary>
            constant precision expressed as a string value
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.DefaultStackSize">
            <summary>
            default stack size in number of bytes
            - overridden if the script defines a stack size 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.PackageStack">
            <summary>
            packages include stackdata 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.EstimateStackSize">
            <summary>
            estimate stack size using input, output and validation parameters 
            - overridden if the script defines a stack size
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.VerboseLogging">
            <summary>
            verbose report logging, log is also blitted to unity
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.TraceLogging">
            <summary>
            enable trace level logging -> will generate a massive report 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.SupportYield">
            <summary>
            if yield is not emitted we can save 20 bytes on the stack, with very small stuff that might be handy
            not implemented .. todo
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.CompileDebug">
            <summary>
            compile the debug function only if enabled 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.ParallelCompilation">
            <summary>
            enable for partially parallel compilation [forcebly disabled]
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.Defines">
            <summary>
            additional compiler defines 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastCompilerOptions.Experimental">
            <summary>
            dont touch if you need to ask 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastCompilerOptions.Default">
            <summary>
            Default compiler options:
            BS1 - Normal - Optimizing
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastCompilerOptions.SSMD">
            <summary>
            Default SSMD compiler options:
            BS1 - SSMD Packagemode - Optimizing
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastCompilerOptions.Entity">
            <summary>
            Default compiler options for packaging entities:
            BS1 - Entity Packagemode - Optimizing
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.#ctor(System.Int32)">
            <summary>
            initialize default options with given stacksize 
            </summary>
            <param name="stack_size">stacksize, stack estimation will be turned off</param>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.#ctor(NSS.Blast.BlastPackageMode)">
            <summary>
            initilize default options in given packaging mode
            </summary>
            <param name="packagemode">the package mode to set</param>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.#ctor(System.Int32,NSS.Blast.BlastPackageMode)">
            <summary>
            initialize default options in given packagemode with a pre-determined stack size
            </summary>
            <param name="stack_size">stacksize, stack estimation will be turned off</param>
            <param name="packagemode">packaging mode</param>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.#ctor">
            <summary>
            initialize with default options 
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.EnableValidation(System.Boolean)">
            <summary>
            enable validation (default = off) 
            </summary>
            <param name="run_auto_validation">true to enable validation</param>
            <returns>options</returns>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.SetStackSize(System.Int32)">
            <summary>
            set the size of the stack, if 0 is set stack is estimated during compilation 
            </summary>
            <param name="stack_size"></param>
            <returns>compiler options</returns>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.PackageWithoutStack">
            <summary>
            package without a stack segment, use stackmemory in the interpretor 
            </summary>
            <returns>compiler options</returns>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.SetLanguage(NSS.Blast.BlastLanguageVersion)">
            <summary>
            Set language target 
            </summary>
            <param name="language">Supported language: BS1 | BSSSMD1 | HPC </param>
            <returns>compiler options</returns>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.SetPackageMode(NSS.Blast.BlastPackageMode)">
            <summary>
            Set packaging mode
            </summary>
            <param name="packagemode">Packagemode: Normal, SSMD or Entity</param>
            <returns>compiler options</returns>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.SetAllocator(Unity.Collections.Allocator)">
            <summary>
            Set allocation mode for packages, use temp with caution in combination with bursted code
            </summary>
            <param name="allocator">the unity memory allocation type</param>
            <returns>compiler options</returns>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.EnableOptimisations">
            <summary>
            enable compiler optimizations, default == enabled
            </summary>
            <returns>compiler options</returns>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.DisableOptimisations">
            <summary>
            disable compiler optimisations, default = enabled
            </summary>
            <returns>compiler options</returns>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.Silent">
            <summary>
            disable all logging, fails silently
            </summary>
            <returns>compiler options</returns>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.Verbose">
            <summary>
            set verbose logging
            </summary>
            <returns>compiler options</returns>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.Trace">
            <summary>
            set trace logging
            </summary>
            <returns>compiler options</returns>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.AddDefine(System.String,System.String,System.Boolean)">
            <summary>
            add a compiled define
            </summary>
            <param name="key">defined name</param>
            <param name="value">value</param>
            <param name="allow_overwrite_existing"></param>
            <returns>compiler options</returns>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.IsDefined(System.String)">
            <summary>
            Check if the key is defined in compiler options 
            </summary>
            <param name="key">the case insensitive key to check</param>
            <returns>true if its defined</returns>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.TryGetDefine(System.String,System.String)">
            <summary>
            Try to lookup a key and get its value
            </summary>
            <param name="key">case insensitive key</param>
            <param name="value">the value if present</param>
            <returns>true if the key was defined</returns>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.ClearDefines">
            <summary>
            remove all defines from compiler options 
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastCompilerOptions.RemoveDefine(System.String)">
            <summary>
            Remove any value possibly assosiated with the key
            </summary>
            <param name="key">case insensitive key</param>
            <returns>true if the key was defined and subsequently removed</returns>
        </member>
        <member name="T:NSS.Blast.BlastScriptFunctionFlag">
            <summary>
            flags for extra information on script functions
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunctionFlag.Reserved">
            <summary>
            function targets a blast reserved function (seed, push, peek) 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunctionFlag.NativeFunction">
            <summary>
            function uses a native function pointer for execution
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunctionFlag.Inlined">
            <summary>
            function is an inlined temporary object that only exists during compilation
            </summary>
        </member>
        <member name="T:NSS.Blast.ReservedBlastScriptFunctionIds">
            <summary>
            IDs reserved for functions used in blast, these get registered to blast with a name (that doesnt need to be equal) 
            </summary>
        </member>
        <member name="F:NSS.Blast.ReservedBlastScriptFunctionIds.Input">
            <summary>
            input mapping function - reserved for internal use
            </summary>
        </member>
        <member name="F:NSS.Blast.ReservedBlastScriptFunctionIds.Output">
            <summary>
            output mapping function - reserved for internal use
            </summary>
        </member>
        <member name="F:NSS.Blast.ReservedBlastScriptFunctionIds.Yield">
            <summary>
            Yield execution 
            </summary>
        </member>
        <member name="F:NSS.Blast.ReservedBlastScriptFunctionIds.Pop">
            <summary>
            Pop something from the stack 
            </summary>
        </member>
        <member name="F:NSS.Blast.ReservedBlastScriptFunctionIds.Peek">
            <summary>
            Peek stack top 
            </summary>
        </member>
        <member name="F:NSS.Blast.ReservedBlastScriptFunctionIds.Seed">
            <summary>
            Seed the random number generator 
            </summary>
        </member>
        <member name="F:NSS.Blast.ReservedBlastScriptFunctionIds.Push">
            <summary>
            Push something to the stack 
            </summary>
        </member>
        <member name="F:NSS.Blast.ReservedBlastScriptFunctionIds.PushFunction">
            <summary>
            Push a function's return value to the stack 
            </summary>
        </member>
        <member name="F:NSS.Blast.ReservedBlastScriptFunctionIds.PushCompound">
            <summary>
            Push the result from executing a compound onto the stack 
            </summary>
        </member>
        <member name="F:NSS.Blast.ReservedBlastScriptFunctionIds.PushVector">
            <summary>
            Push a vector directly onto the stack 
            </summary>
        </member>
        <member name="F:NSS.Blast.ReservedBlastScriptFunctionIds.Debug">
            <summary>
            Output debuginformation to the debug stream about given parameter 
            </summary>
        </member>
        <member name="F:NSS.Blast.ReservedBlastScriptFunctionIds.DebugStack">
            <summary>
            Output debuginformation to the debug stream
            </summary>
        </member>
        <member name="F:NSS.Blast.ReservedBlastScriptFunctionIds.Offset">
            <summary>
            all other functions start indexing from this offset
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastScriptFunction">
            <summary>
            burst compatible function description 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunction.NativeFunctionPointer">
            <summary>
            a native function pointer (1st member, makes sure its aligned if this struct is)
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunction.FunctionId">
            <summary>
            function Id, doubles as index into function tables
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunction.Match">
            <summary>
            char array to match to in lowercase, only ASCII
            - length == Blast.MaximumFunctionNameLength
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunction.MinParameterCount">
            <summary>
            minimal number of parameters 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunction.MaxParameterCount">
            <summary>
            maximal number of parameters, 0 for none, max = 31 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunction.ReturnsVectorSize">
            <summary>
            vectorsize of returnvalue, 0 if no value is returned
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunction.AcceptsVectorSize">
            <summary>
            vectorsize of accepted values in parameters, set to 0 to perform no check
            - TODO, V2/3/4?? could make this more strict
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunction.Flags">
            <summary>
            Flags: 
            - reserved: function targets a reserved function
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunction.ScriptOp">
            <summary>
            Built-in functions directly compile into a script operation
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunction.ExtendedScriptOp">
            <summary>
            Built-in functions directly compile into a script operation
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptFunction.IsReserved">
            <summary>
            true if the function targets a reserved function name 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptFunction.IsExternalCall">
            <summary>
            True if the functioncall is an external functionpointer
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptFunction.IsPopVariant">
            <summary>
            true if function encodes a pop function
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptFunction.IsPushVariant">
            <summary>
            true function encodes a push operation 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptFunction.CanHaveParameters">
            <summary>
            true if the function can have parameters
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptFunction.HasVariableParameterCount">
            <summary>
            returns true if the function accepts a variable sized list of paramaters 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptFunction.IsNotValid">
            <summary>
            returns if the function is NOT valid (checks id, assumes memory is initialized to zeros)
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptFunction.IsValid">
            <summary>
            returns if the function is valid (checks id, assumes memory is initialized to zeros)
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScriptFunction.Generic``1">
            <summary>
            cast our functionpointer into the delegate used to call it
            </summary>
            <typeparam name="T">the delegate type</typeparam>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptFunction.GetFunctionName">
            <summary>
            rebuilds the functionname from a native character array (expensive operation) 
            </summary>
            <returns>the string representing the functionname</returns>
        </member>
        <member name="T:NSS.Blast.BlastScriptFunctionInfo">
            <summary>
            managed information on functions 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunctionInfo.Function">
            <summary>
            the native function data contains id, information and function pointer 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunctionInfo.Match">
            <summary>
            the identifier to match the function to = function name
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunctionInfo.CSName">
            <summary>
            the identifier used in CS code - DONT USE
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptFunctionInfo.Parameters">
            <summary>
            [Optional] parameter names, these dont dictate min/max parametercount 
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScriptFunctionInfo.ToString">
            <summary>
            tostring override for better view in debugger
            </summary>
            <returns></returns>
        </member>
        <member name="P:NSS.Blast.BlastScriptFunctionInfo.HasVariableParameterCount">
            <summary>
            true if the function has a variable length parameter list
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastScriptAPI">
            <summary>
            For now, just a collection of function pointers that holds a native list with function information
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptAPI.Name">
            <summary>
            name of the api
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptAPI.Functions">
            <summary>
            native function definition info 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptAPI.FunctionInfo">
            <summary>
            managed information, includes a copy of the native info
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptAPI.Allocator">
            <summary>
            allocated to be used for any data comming from this api
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptAPI.IsInitialized">
            <summary>
            true if native function pointer data is initialized/allocated
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptAPI.FunctionCount">
            <summary>
            number of functions defined in this api
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.#ctor(Unity.Collections.Allocator)">
            <summary>
            Constructor for a new blastscriptapi instance, provides native allocator
            </summary>
            <param name="allocator"></param>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.Initialize">
            <summary>
            Initialize native function pointer stack 
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.Dispose">
            <summary>
            dispose of any native memory that could be allocated for holding function pointer information 
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.Destroy">
            <summary>
            destroy native allocations, return to uninitialized state 
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.RegisterFunction(NSS.Blast.ReservedBlastScriptFunctionIds,System.String,System.Int32,System.Int32,System.Int32,System.Int32,NSS.Blast.blast_operation)">
            <summary>
            Register a function with blast
            </summary>
            <param name="id">a reserved function id</param>
            <param name="name">functino name</param>
            <param name="min_param_count">minimal parameter count</param>
            <param name="max_param_count">maximum parameter count</param>
            <param name="accept_vector_size">accepted vector size, 0 for any</param>
            <param name="return_vector_size">returned verctor size, 0 for any</param>
            <param name="op">blast operation used to encode it</param>
            <returns>returns a unique (within the blast instance) function id</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.RegisterFunction(NSS.Blast.ReservedBlastScriptFunctionIds,System.String,System.Int32,System.Int32,System.Int32,System.Int32,NSS.Blast.extended_blast_operation)">
            <summary>
            Register a function with blast
            </summary>
            <param name="id">a reserved function id</param>
            <param name="name">functino name</param>
            <param name="min_param_count">minimal parameter count</param>
            <param name="max_param_count">maximum parameter count</param>
            <param name="accept_vector_size">minimal vector size, 0 for any</param>
            <param name="return_vector_size">max verctor size, 0 for any</param>
            <param name="op">extended blast operation used to encode it</param>
            <returns>returns a unique (within the blast instance) function id</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.RegisterFunction(System.String,System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Register a function with blast
            </summary>
            <param name="nativefunction">a native function pointer</param>
            <param name="name">functino name</param>
            <param name="parameter_count">parameter count</param>
            <param name="accept_vector_size">minimal vector size, 0 for any</param>
            <param name="return_vector_size">max verctor size, 0 for any</param>
            <returns>returns a unique (within the blast instance) function id</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.RegisterFunction(System.String,System.Int32,System.Int32,System.Int32,System.Int32,NSS.Blast.blast_operation)">
            <summary>
            Register a function with blast
            </summary>
            <param name="name">functino name</param>
            <param name="min_param_count">minimal parameter count</param>
            <param name="max_param_count">maximum parameter count</param>
            <param name="accept_vector_size">minimal vector size, 0 for any</param>
            <param name="return_vector_size">max verctor size, 0 for any</param>
            <param name="op">blast operation used to encode it</param>
            <returns>returns a unique (within the blast instance) function id</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.RegisterFunction(System.String,System.Int32,System.Int32,System.Int32,System.Int32,NSS.Blast.extended_blast_operation)">
            <summary>
            Register a function with blast
            </summary>
            <param name="name">functino name</param>
            <param name="min_param_count">minimal parameter count</param>
            <param name="max_param_count">maximum parameter count</param>
            <param name="accept_vector_size">minimal vector size, 0 for any</param>
            <param name="return_vector_size">max verctor size, 0 for any</param>
            <param name="op">blast operation used to encode it</param>
            <returns>returns a unique (within the blast instance) function id</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.RegisterFunction(System.String,NSS.Blast.BlastVariableDataType,System.String[])">
            <summary>
            register an external function name within the blast script API, while no functionpointer is supplied 
            the name is registered for later use
            </summary>
            <remarks>
            
            </remarks>
            <param name="name">the functionname, which is asserted to be unique</param>
            <param name="returns">the variable type returned</param>
            <param name="parameters">a list of parameter names, used for visualization only</param>
            <returns>an unique id for this function</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.RegisterFunction(System.IntPtr,System.String,NSS.Blast.BlastVariableDataType,System.String[])">
            <summary>
            register functionpointer as an external call 
            </summary>
            <param name="fp">the function pointer, if null a reservation is still made for the id</param>
            <param name="name">the function name, may not contain tokens or reserved words</param>
            <param name="returns">the returned datatype</param>
            <param name="parameters">array of parameter names, used for visualizations only</param>
            <returns>an unique id for this function, negative errorcodes on error</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.UpdateRegistration(System.Int32,System.IntPtr)">
            <summary>
            Update the function pointer belonging to a registration 
            </summary>
            <param name="id">the function's id, it is asserted to exist</param>
            <param name="fp">the function pointer, may update to zero</param>
            <returns>success or error code</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.GetFunctionByOpCode(NSS.Blast.blast_operation)">
            <summary>
            lookup a function definition that is directly linked to an interpretor operation 
            </summary>
            <param name="op">the operation that should translate to a function used during interpretation</param>
            <returns>a function definition</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.FunctionExists(System.String)">
            <summary>
            check if a function exists by its name 
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.GetFunctionByName(System.String)">
            <summary>
            lookup a function definition that is directly linked to an interpretor operation 
            </summary>
            <param name="name">the name of the function to lookup</param>
            <returns>a function definition</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.GetFunctionById(NSS.Blast.ReservedBlastScriptFunctionIds)">
            <summary>
            lookup a function definition that is directly linked to an interpretor operation 
            </summary>
            <param name="function_id">the reserved id of the function to lookup</param>
            <returns>a function definition</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.GetFunctionById(System.Int32)">
            <summary>
            lookup a function definition that is directly linked to an interpretor operation 
            </summary>
            <param name="function_id">the unique id of the function to lookup</param>
            <returns>a function definition</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.GetFunctionDataById(System.Int32)">
            <summary>
            Directly get a function using the id as an index 
            </summary>
            <param name="id">function id/index</param>
            <returns>the script function object</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.TryGetFunctionCallById(System.Int32,NSS.Blast.BlastScriptFunction@)">
            <summary>
            try to get a function by id, in release it just gets it, in debug it checks  
            </summary>
            <param name="id">function id/index</param>
            <param name="function">function</param>
            <returns>true if found</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptAPI.IsVariableParamFunction(NSS.Blast.blast_operation)">
            <summary>
            returns true if the function accepts a variable sized list of paramaters 
            </summary>
            <param name="op">the operation mapping to a function</param>
            <returns>true if the function exists and has a variable parameter list</returns>
        </member>
        <member name="T:NSS.Blast.CoreAPI">
            <summary>
            Implements Core-API functionality 
            </summary>
        </member>
        <member name="M:NSS.Blast.CoreAPI.#ctor(Unity.Collections.Allocator)">
            <summary>
            Extend BlastScriptAPI (core just is a shell) 
            </summary>
            <param name="allocator"></param>
        </member>
        <member name="M:NSS.Blast.CoreAPI.RegisterCoreAPI">
            <summary>
            register all base functions
            </summary>
        </member>
        <member name="M:NSS.Blast.Cache.blast.max(System.Single,System.Single)">
            <summary>
            hmmmmz we would neeed very many overloads when supporting 63 parameters... 
            </summary>
        </member>
        <member name="M:NSS.Blast.CodeUtils.GetBytesView(System.Byte*,System.Int32,System.Int32,System.Boolean)">
            <summary>
            return bytes formatted as 000| 000 000 000 000 000 000 000 000 
            </summary>
            <param name="code"></param>
            <param name="length"></param>
            <param name="column_count"></param>
            <param name="use_index"></param>
            <returns></returns>
        </member>
        <member name="T:NSS.Blast.CastUtil">
            <summary>
            
            cast 1 refernce to another
            
            Quaternion q;
            ref float4 f = ref CastUtil.RefToRef(q);
            f.w = 123;
            print(q.w); // 123
            </summary>
        </member>
        <member name="T:NSS.Blast.ListCache`1">
            <summary>
             a static list cache, caches only a single list of a preset small capacity
            </summary>
        </member>
        <member name="M:NSS.Blast.ListCache`1.Acquire(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:NSS.Blast.ListCache`1.Release(System.Collections.Generic.List{`0})">
            <summary>
            
            </summary>
        </member>
        <member name="M:NSS.Blast.ListCache`1.ReleaseArray(System.Collections.Generic.List{`0})">
            <summary>
            
            </summary>
        </member>
        <member name="T:NSS.Blast.StringBuilderCache">
            <summary>
            copied with minor changes from ms cli reference source  
            https://referencesource.microsoft.com/#mscorlib/system/text/stringbuildercache.cs,40
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastRuntimeVersions">
            <summary>
            Versions of blast present in build
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastRuntimeVersions.Final1">
            <summary>
            the final version 1 = release 1
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastLanguageVersion">
            <summary>
            the different compiler outputs / language targets 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastLanguageVersion.None">
            <summary>
            unknown language version
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastLanguageVersion.BS1">
            <summary>
            BLAST Script, default script / bytecode 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastLanguageVersion.BSSMD1">
            <summary>
            BLAST Single Script Multiple Data
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastLanguageVersion.HPC">
            <summary>
            Burstable C# code packed in functions for burst to compile at designtime
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastLanguageVersion.CS">
            <summary>
            Runtime compiled c# code, .net framework and windows only 
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastVectorSizes">
            <summary>
            supported vectorsizes 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVectorSizes.float1">
            <summary>
            size 1: 4 bytes
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVectorSizes.float2">
            <summary>
            size 2: 8 bytes
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVectorSizes.float3">
            <summary>
            size 3: 12 bytes
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVectorSizes.float4">
            <summary>
            size 4: 16 bytes
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastVariableDataType">
            <summary>
            supported variable data types 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariableDataType.Numeric">
            <summary>
            float datatype
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariableDataType.Numeric64">
            <summary>
            double datatype 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariableDataType.ID">
            <summary>
            integer datatype 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariableDataType.ID64">
            <summary>
            long datatype 
            </summary>
        </member>
        <member name="T:NSS.Blast.vector_index">
            <summary>
            when encoding xxx xxy etc:
            
            byte: 00112233
            
            </summary>
        </member>
        <member name="T:NSS.Blast.floatindex">
            <summary>
            combination of vectorsize and datatype 
            </summary>
        </member>
        <member name="T:NSS.Blast.blast_operation">
            <summary>
            instruction set bs1
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.nop">
            <summary>
            signals end of a stream
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.assign">
            <summary>
            starts reading a stream of opcodes
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.assigns">
            <summary>
            assign single variable / pop to assignee
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.assignf">
            <summary>
            assign function result to assignee
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.assignfe">
            <summary>
            assign result of external function call 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.assignfn">
            <summary>
            assign negated function result to assignee
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.assignfen">
            <summary>
            assign negated result of external function call to assignee
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.assignv">
            <summary>
            assign a single vector, assignv knows the size of the parameter it writes to so it doesnt need a datapoint for vectorsize 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.add">
            <summary>
            add 2 operands
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.substract">
            <summary>
            substract 2 operands, doubles as negative sign 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.divide">
            <summary>
            divide 2 operands
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.multiply">
            <summary>
            multiply 2 operands 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.and">
            <summary>
            boolean and operation
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.or">
            <summary>
            boolean or operation
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.not">
            <summary>
            boolean not 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.xor">
            <summary>
            boolean xor
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.greater">
            <summary>
            boolean greater >
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.greater_equals">
            <summary>
            boolean greater equals >=
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.smaller">
            <summary>
            boolean smaller then 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.smaller_equals">
            <summary>
            boolean smaller equals
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.equals">
            <summary>
            boolean equals: = 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.not_equals">
            <summary>
            boolean inequality: != 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.ret">
            <summary>
            return -> terminate script
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.yield">
            <summary>
            Yield script, writing state to stack, must have packaged stack data
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.begin">
            <summary>
            begin a compounded sequence
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.end">
            <summary>
            end a compounded sequence
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.jz">
            <summary>
            jump if zero
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.jnz">
            <summary>
            jump if not zero
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.jump">
            <summary>
            unconditional jump forward
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.jump_back">
            <summary>
            unconditional jump backward
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.long_jump">
            <summary>
            jump short value (+- 32K), short is encoded in net 2 bytes 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.push">
            <summary>
            push a value onto the stack
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.pop">
            <summary>
            pop a value from the stack
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.pushv">
            <summary>
            Push a vector to the stack
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.pushf">
            <summary>
            push the result of a function onto the stack 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.pushc">
            <summary>
            push the result of a sequence onto the stack 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.peek">
            <summary>
            peek stack data 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.peekv">
            <summary>
            peek vector data 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.fma">
            <summary>
            Multiply add: a = m1 * m2 + a1
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.adda">
            <summary>
            add all operands in sequence
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.mula">
            <summary>
            multiply all operands in sequence
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.diva">
            <summary>
            divide all operands by eachother in sequence 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.suba">
            <summary>
            substract all operands from eachother in sequence
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.all">
            <summary>
            returns true if all arguments are true
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.any">
            <summary>
            returns true if any argument is true 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.abs">
            <summary>
            return absolute value of operand
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.select">
            <summary>
            select instruction 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.random">
            <summary>
            generate a random number 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.seed">
            <summary>
            seed the random number generator 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.max">
            <summary>
            get max value from operands, returns vector of same size as inputs 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.min">
            <summary>
            get min value from operands, returns vector of same size as inputs 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.maxa">
            <summary>
            get max argument from operands returns size 1 vector
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.mina">
            <summary>
            get min argument from operands returns size 1 vector
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.fmod">
            <summary>
            floating point modulus operation 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.csum">
            <summary>
            component sum of vector 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.trunc">
            <summary>
            truncate float into integer part only 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.index_x">
            <summary>
            index the x component of a vector
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.index_y">
            <summary>
            index the y component of a vector
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.index_z">
            <summary>
            index the z component of a vector
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.index_w">
            <summary>
            index the w component of a vector 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.index_n">
            <summary>
            index the vector of n size with an m size indexer: x, xy, zzz etc. 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.pi">
            <summary>
            PI
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.inv_pi">
            <summary>
            Inverse of PI 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.epsilon">
            <summary>
            The difference between 1.0f and the next representable f32/single precision number.
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.infinity">
            <summary>
            positive infinity value 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.negative_infinity">
            <summary>
            negative infinity value
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.nan">
            <summary>
            Not a number 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.min_value">
            <summary>
            smallest positive value for datatype
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_0">
            <summary>
            constant 0
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_1">
            <summary>
            constant 1
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_2">
            <summary>
            constant 2
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_3">
            <summary>
            constant 3
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_4">
            <summary>
            constant 4 
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_8">
            <summary>
            constant 8
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_10">
            <summary>
            constant 10
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_16">
            <summary>
            constant 16
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_24">
            <summary>
            constant 24
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_32">
            <summary>
            constant 32
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_64">
            <summary>
            constant 64
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_100">
            <summary>
            constant 100
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_128">
            <summary>
            constant 128
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_256">
            <summary>
            constant 256
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_512">
            <summary>
            constant 512
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_1000">
            <summary>
            constant 1000
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_1024">
            <summary>
            constant 1024
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_30">
            <summary>
            constant 30
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_45">
            <summary>
            constant 45
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_90">
            <summary>
            constant 90
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_180">
            <summary>
            constant 180
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_270">
            <summary>
            constant 270
            </summary>
        </member>
        <member name="F:NSS.Blast.blast_operation.value_360">
            <summary>
            constant 360
            </summary>
        </member>
        <member name="F:NSS.Blast.extended_blast_operation.remap">
            <summary>
            remap e from range a-b to c-d  
            </summary>
        </member>
        <member name="F:NSS.Blast.extended_blast_operation.unlerp">
            <summary>
            normalize x to range a-b |  (x - a) / (b - a).
            </summary>
        </member>
        <member name="F:NSS.Blast.extended_blast_operation.ceillog2">
            <summary>
            get log2 ceiling of value
            </summary>
        </member>
        <member name="F:NSS.Blast.extended_blast_operation.floorlog2">
            <summary>
            get log2 floor of value
            </summary>
        </member>
        <member name="F:NSS.Blast.extended_blast_operation.ceilpow2">
            <summary>
            get next power of 2 of value
            </summary>
        </member>
        <member name="F:NSS.Blast.extended_blast_operation.debugstack">
            <summary>
            log stack contents in debugstream
            </summary>
        </member>
        <member name="F:NSS.Blast.extended_blast_operation.debug">
            <summary>
            log variable contents in debugstream 
            </summary>
        </member>
        <member name="F:NSS.Blast.extended_blast_operation.call">
            <summary>
            call an external function, opcode is followed by 4 byte id 
            TODO: update to also have a callsmall and call medium with 1 and 2 bytes for external function index? 
            </summary>
        </member>
        <member name="F:NSS.Blast.extended_blast_operation.ex">
            <summary>
            extensions on extensions... better use another ex in blast_operation, save 1 byte if ever needed
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastScriptToken">
            <summary>
            The tokens used in languageversions: BS1|BS2|BSSSDM1
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Nop">
            <summary>
            nop instruction 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Add">
            <summary>
            add 2 operands together <c>a = a + b;</c>
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Substract">
            <summary>
            substract 2 operands from eachother <c>a = a - b;</c>
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Divide">
            <summary>
            divide 2 operands: <c>a = a / b;</c>
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Multiply">
            <summary>
            multiply 2 operands: <c>a = a * b;</c>
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Equals">
            <summary>
            boolean equals, returns 1 for true, 0 for false; <c>a = a == b;</c>
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.TernaryOption">
            <summary>
            de double colon ':', used in switch statements and ternary operations: 
            <remarks>
            <code>
            a = 1 ? 1 : 0; 
            switch(a) 
            (
                case 1: 
                (
                    b = 2;
                )
                default: 
                (  
                    b = 3;
                )
            )    
            </code>
            </remarks>
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.SmallerThen">
            <summary>
            boolean comparison smaller then, not including
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.GreaterThen">
            <summary>
            boolean comparison greater then, not including
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.SmallerThenEquals">
            <summary>
            boolean comparison smaller then, including
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.GreaterThenEquals">
            <summary>
            boolean comparison greater then, including
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.NotEquals">
            <summary>
            boolean comparison not equals 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.And">
            <summary>
            boolean AND operation, numeric 0 == false
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Or">
            <summary>
            boolean OR operation, numeric 0 == false
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Xor">
            <summary>
            boolean XOR operation, number 0 == false
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Not">
            <summary>
            boolean NOT operation, number 0 == false 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.OpenParenthesis">
            <summary>
            opens a set of statement(s): a compound | sequence
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.CloseParenthesis">
            <summary>
            closes a set of statement(s): a compound | sequence
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.DotComma">
            <summary>
            statement terminator: ; 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Comma">
            <summary>
            parameter seperator: , 
            </summary>
            <remarks>
            Prevents parameters from growing into vectors or algorithmic sequences:
            
            Define vector with 1 element minus 1. without the , the statement would be ambigious
            <code>
            a = (1, -1);  // a 2 vector 
            a = (1 - 1);  // a 1 vector | scalar
            </code>
            </remarks>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Identifier">
            <summary>
            a general identifier: values functions keywords 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Indexer">
            <summary>
            a decimal seperator doubling as an indexer: .  indexing is not yet supported
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.IndexOpen">
            <summary>
            an index opener [, not yet supported
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.IndexClose">
            <summary>
            an index closer [, not yet supported
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.If">
            <summary>
            the if condition of an if then else statement clause
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Then">
            <summary>
            the then compound of an if then else clause
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Else">
            <summary>
            the else compound of an if then else clause
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.While">
            <summary>
            a while loop 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NSS.Blast.BlastScriptToken.For" -->
        <member name="F:NSS.Blast.BlastScriptToken.Switch">
            <summary>
            the switch statement, there must be at least 1 case or 1 default statement. 
            </summary>
            <remarks>
            <code>
            a = 1 ? 1 : 0; 
            switch(a) 
            (
                case 1: 
                (
                    b = 2;
                )
                default: 
                (  
                    b = 3;
                )
            )    
            </code>
            </remarks>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Case">
            <summary>
            the case statement, the condition in switch is matched to the value in case, if they match that path is taken
            </summary>
            <remarks>
            <code>
            a = 1 ? 1 : 0; 
            switch(a) 
            (
                case 1: 
                (
                    b = 2;
                )
                default: 
                (  
                    b = 3;
                )
            )    
            </code>
            </remarks>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Default">
            <summary>
            the default case, part of the switch statement and chosen when no other case applies 
            </summary>
            <remarks>
            <code>
            a = 1 ? 1 : 0; 
            switch(a) 
            (
                case 1: 
                (
                    b = 2;
                )
                default: 
                (  
                    b = 3;
                )
            )    
            </code>
            </remarks>
        </member>
        <member name="F:NSS.Blast.BlastScriptToken.Function">
            <summary>
            function defining a value  (or does nothing to registers and is actually a procedure) 
            </summary>
            <remarks>
            
            </remarks>
        </member>
        <member name="T:NSS.Blast.BlastScriptTokenDefinition">
            <summary>
            definition of a token used in blast script 
            </summary>
            <remarks>
            A token definition is used to provide more information on tokens, mainly for debugging, but also for ease
            of possible future extensions 
            </remarks>
        </member>
        <member name="P:NSS.Blast.BlastScriptTokenDefinition.Token">
            <summary>
            the token being defined
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptTokenDefinition.Match">
            <summary>
            the character to match to 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptTokenDefinition.Description">
            <summary>
            description of token 
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScriptTokenDefinition.#ctor(NSS.Blast.BlastScriptToken,System.Char,System.String)">
            <summary>
            token constructor 
            </summary>
            <param name="token">token id</param>
            <param name="match">char to match</param>
            <param name="description">description of the token</param>
        </member>
        <member name="T:NSS.Blast.BlastError">
            <summary>
            Errorcodes that can be returned by blast 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.yield">
            <summary>
            execution returned back to caller 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.success">
            <summary>
            everything went OK
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error">
            <summary>
            a generic error occured 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_unknown_op">
            <summary>
            an unknown operation was found
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_assign_vector_size_mismatch">
            <summary>
            a vector is assigned to a variable of differnt vectorsize and no automatic conversion is possible or implemented
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_begin_end_sequence_in_root">
            <summary>
            a begin-end opcode sequence is found in root while that should not be possible
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_unsupported_operation_in_root">
            <summary>
            an operation is encountered that is not supported while executing root level nodes
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_variable_vector_op_not_supported">
            <summary>
            a variable vector operation is not supported by the current sequence of operations
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_update_vector_fail">
            <summary>
            failed to update a vector
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.stack_error_peek">
            <summary>
            error peeking stack information 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.stack_error_pop">
            <summary>
            error taking values from stack
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.stack_error_variable_pop_not_supported">
            <summary>
            a variable sized pop is not supported
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.stack_error_pop_multi_from_root">
            <summary>
            a pop instruction is found where it doesnt belong 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_variable_vector_compound_not_supported">
            <summary>
            a variably sized compound is not supported in the current sequence of operations 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_max_iterations">
            <summary>
            the interpretor reached the maximum number of iterations, this is an indication of scripts running in an endless loop
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.validate_error_stack_too_small">
            <summary>
            the allocated space for the stack is too small (to few stack memory locations)
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.script_id_not_found">
            <summary>
            the given script id could not be found
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_blast_not_initialized">
            <summary>
            blast engine data is not initialized (use: Blast.Create()         
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_invalid_script_id">
            <summary>
            the given script id is invalid in the current context 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_cs_compiler_not_supported_on_platform">
            <summary>
            the c-sharp compiler is only supported in .Net Framework builds on windows. 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_invalid_nodetype">
            <summary>
            the node type is invalid in the current context 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_unsupported_operation">
            <summary>
            the operation is not supported in the current context 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_node_not_flat">
            <summary>
            the node has not been sufficiently flattened for execution 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_failed_to_compile_function_parameters">
            <summary>
            1 or more function parameters failed to be compiled 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_too_many_parameters">
            <summary>
            a function is used with too many parameters 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_failed_to_translate_offset_into_index">
            <summary>
            failed to translate a dataoffset into a variable index, the bytecode uses offsets instead of id;s voiding the need for some checks
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_vector_size_not_supported">
            <summary>
            the given vectorsize is not supported by the target operation 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.datasegment_size_larger_then_target">
            <summary>
            the datasegment is too large to be mapped to the target buffer 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.compile_packaging_error">
            <summary>
            the compiler failed to package the compiled bytecode 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.ssmd_invalid_packagemode">
            <summary>
            invalid packagemode set in package for ssmd execution
            - packages need to be compiled in SSMD mode for SSMD interpretation (it can still run normal interpretation on ssmd packages though)
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_unsupported_operation_in_ssmd_root">
            <summary>
            the current operation is not supported at the root level during ssmd interpretation
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.ssmd_error_expecting_value">
            <summary>
            the ssmd interpretor expected a value but received something else
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.ssmd_error_unsupported_vector_size">
            <summary>
            the current vectorsize is not supported in the current sequence of operations
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_execute_package_not_correctly_set">
            <summary>
            package not correctly set to interpretor, use interpretor.SetPackage();
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_invalid_nodetype_in_root">
            <summary>
            the ast nodetype is not allowed in the root, this indicates compiler errors 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_node_function_unknown">
            <summary>
            the ast node encodes an unknown function 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_failed_to_flatten_function_parameters">
            <summary>
            the flatten operation failed on parameters of the target function node
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_pushv_vector_size_not_supported">
            <summary>
            the currentvector size is not supported to be pushed to the stack 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_optimizer_operation_mismatch">
            <summary>
            the optimizer failed to match operations 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_optimizer_parameter_mismatch">
            <summary>
            the optimizer failed to match parameters
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_optimizer_failed_to_replace_sequence">
            <summary>
            the optimizer failed to replace a sequence it targetted to optimize
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_package_not_allocated">
            <summary>
            the given package doesnt have any allocated code or data segments 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_nothing_to_execute">
            <summary>
            there is nothing to execute
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_packagemode_not_supported_for_direct_execution">
            <summary>
            the packagemode is not supported in the given execution method
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_already_packaged">
            <summary>
            package alread created, usually means that 'Prepare' is called while the script is already prepared 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_compilation_failure">
            <summary>
            generic error during compilation of the script, the log could contain more data depending on compilation options
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_language_version_not_supported">
            <summary>
            language version not supported in given context
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.ssmd_invalid_operation">
            <summary>
            invalid operation in ssmd sequence
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.ssmd_function_not_handled">
            <summary>
            function not handled in ssmd operation 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_pre_compile_cleanup">
            <summary>
            error in cleanup stage before compilation 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_analyzer">
            <summary>
            error in analyzer
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_mapping_parameters">
            <summary>
            analyzer failed to determine all parameter types, vectorsizes and reference counts
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_scriptapi_function_already_exists">
            <summary>
            an attempt was made to register a function with the scriptapi that already exists 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_scriptapi_function_not_registered">
            <summary>
            an attempt was made to use a function that is not known to the script api registry
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_ssmd_sync_buffer_to_deep">
            <summary>
            syncbuffer growing to deep, either reduce nesting or increase sync buffer depth
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_inlinefunction_parameter_list_syntax">
            <summary>
            inline function definition has a malformed parameter list 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_inlinefunction_body_syntax">
            <summary>
            inline function definition has a malformed body compound
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_inlinefunction_declaration_syntax">
            <summary>
            inline function declaration is malformed (probably malformed function name)
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_inlinefunction_already_exists">
            <summary>
            inline function already exists
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_inlinefunction_doenst_exist">
            <summary>
            inline function definition doesnt exist/couldnt be found
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_inlinefunction_parameters">
            <summary>
            error re-mapping parameter list during inlining of function 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_inlinefunction_may_not_declare_variables">
            <summary>
            error: inlined functions may not allocate memory/declare variables 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_inlinefunction_failed_to_remap_identifiers">
            <summary>
            error failed to remap identifiers in inlined function segment  
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_indexer_transform">
            <summary>
            error transforming node indexers 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastError.error_assign_component_from_vector">
            <summary>
            error in assign, cannot set a vector component from a multicomponent vector
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastPackageMode">
            <summary>
            Blast script packaging types 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageMode.Normal">
            <summary>
            Compile all into a single package, code data and stack combined  
            <code>
            [----CODE----|----METADATA----|----DATA----|----STACK----]
                         1                2            3             4  
            
            ** ALL OFFSETS IN PACKAGE IN BYTES ***
            
            1 = metadata offset 
            2 = data_offset 
            3 = stack_offset 
            4 = package_size  
            </code>
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageMode.SSMD">
            <summary>
            SSMD Package with code and metadata seperate from datastack
            <code>
            - SSMD requirement: while data changes, its intent does not so metadata is shared
            
            - SSDM in V2/BS2 allows for (nested) branching by setting sync points on non constant jumps: 
            -- loop ends
            -- if then else jumps 
            
            [----CODE----|----METADATA----]       [----DATA----|----STACK----]
                         1                2                    3             4
            
            1 = metadata offset 
            2 = codesegment size 
            3 = stack offset 
            4 = datasegment size 
            
            prop stacksize (in elements) => (datasegment size - stack_offset) / 4
            </code>
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageMode.Entity">
            <summary>
            Entity Package: the script's code is seperated from all data
            <code>
            [----CODE----]      [----METADATA----|----DATA----|----STACK----]
                         1                       2            3             4
            
            1 = codesegment size 
            2 = metadata size 
            3 = stack offset 
            4 = datasegment size 
            </code>
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageMode.Compiler">
            <summary>
            <code>
            package type used by compiler 
            
            - THE POINTERS ARE INVALID
            
            [----CODE----]      [----METADATA----]     [----DATA----|----STACK----]
                         1                       2                  3             4
            
            1 = codesegment size 
            2 = metadata size 
            3 = datasize in bytes / stack offset in bytes 
            4 = datasegment size = stackcapacity = 4 - 3  
            </code>
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastPackageFlags">
            <summary>
            Package Flags
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageFlags.None">
            <summary>
            full data allocated, package can be directly executed 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageFlags.NoStack">
            <summary>
            package is allocated without stack data (template for SSMD) 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageFlags.Aligned4">
            <summary>
            align data offsets on a 4 byte boundary
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageFlags.Aligned8">
            <summary>
            align data offsets on a 4 byte boundary
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastMetaDataStack">
            <summary>
            a pointer to meta-data-stack memory
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastSSMDDataStack">
            <summary>
            data for ssmd operation modes: data-stack only
            - only used as pointer, fields handy in debugger
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastPackageData">
            <summary>
            the bare minimum data (28 bytes) to package a script for execution 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageData.CodeSegmentPtr">
            <summary>
            points to codesegment, may be shared with other segments, see packagemode
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageData.P2">
            <summary>
            points to the other segment, see packagemode
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageData.PackageMode">
            <summary>
            Script packaging mode
            </summary>
            <remarks>
            <code>
            Packaging mode 
            
            NORMAL: 
                    [----CODE----|----METADATA----|----DATA----|----STACK----]
                                 1                2            3             4  
            
            SSMD:
                    [----CODE----|----METADATA----]       [----DATA----|----STACK----]
                                 1                2                    3             4
            
            ENTITY:
                    [----CODE----]      [----METADATA----]     [----DATA----|----STACK----]
                                 1                       2                  3             4
            </code>
            </remarks>
        </member>
        <member name="F:NSS.Blast.BlastPackageData.LanguageVersion">
            <summary>
            Package languageversion, determines feature support 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageData.Flags">
            <summary>
            Package flags, see flags enumeration  
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageData.Allocator">
            <summary>
            Package memory allocator 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageData.O1">
            <summary>
            Offset 1, intent depends on packagemode
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageData.O2">
            <summary>
            Offset 2, intent depends on packagemode
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageData.O3">
            <summary>
            Offset 3, intent depends on packagemode
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastPackageData.O4">
            <summary>
            Offset 4, intent depends on packagemode
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.CodeSize">
            <summary>
            size of code in bytes, maps to O1 in all package modes 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.MetadataSize">
            <summary>
            metadata size in bytes, may include alignment bytes in normal and SSMD modes  
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.DataSize">
            <summary>
            data size in bytes, may include alignment bytes 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.StackSize">
            <summary>
            stack size in bytes, may not be a multiple of elementsize/4bytes
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.CodeSegmentSize">
            <summary>
            the allocated datasize in bytes of the codesegment pointer 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.DataSegmentSize">
            <summary>
            the size if stack would be included, while on normal packaging mode there is no seperate buffer there is a size
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.SSMDDataSize">
            <summary>
            bytesize for needed BlastSSMDDataStack records
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.AllocatedDataSegmentSize">
            <summary>
            the size with stack included depending on flags
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.StackCapacity">
            <summary>
            the maxiumum stack capacity in elements (1 element == 32 bit)
            - looks at flags, if == nostack then returns a capacity of 0
            - IMPORTANT NOTE: looking at profiler this really should be cached if asked a lot 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.DataSegmentStackOffset">
            <summary>
            stack offset in bytes as seen from the start of datasegment
            - stack and datasegment MUST ALWAYS be in the same segment so that Data[last] == Stack[-1] 
            - when using .Stack[] offset is 0
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.MetadataPtr">
            <summary>
            Calculated pointer to metadata 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.DataSegmentPtr">
            <summary>
            pointer to data segment as calculated from package configuration 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.StackSegmentPtr">
            <summary>
            pointer to stack segment as calculated from package configuration 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.Code">
            <summary>
            Code[] pointer 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.Metadata">
            <summary>
            metadata[], 1 byte of metadata for each dataelement in stack and datasegment 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.Data">
            <summary>
            data[] pointer 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.Stack">
            <summary>
            Stack[] pointer -> Data[last] == Stack[-1]
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.HasStack">
            <summary>
            true if memory for stack is allocated, 
            false if not: 
            - yield not possible without persistant stack 
            - we call it TLS, thread level stack/storage 
            - Faster in small multithreaded bursts, benefit fades in very large bursts 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastPackageData.IsAllocated">
            <summary>
            true if memory has been allocated for this object
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastPackageData.CloneData(System.Int32)">
            <summary>
            clone n data segments into 1 block and index it with pointers 
            - the first block contains the root pointer which can be freed 
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastPackageData.CloneDataStack(System.Int32)">
            <summary>
            clone n data segments into 1 block and index it with pointers 
            - the first block contains the root pointer which can be freed 
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastPackageData.CloneData(System.Int32,Unity.Collections.Allocator)">
            <summary>
            clone n segments into 1 memory block and index it with pointers 
            - the first block contains the root pointer to free later
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastPackageData.CloneDataStack(System.Int32,Unity.Collections.Allocator)">
            <summary>
            clone n segments into 1 memory block and index it with pointers 
            - the first block contains the root pointer to free later
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastPackageData.CloneData(System.Int32,NSS.Blast.BlastMetaDataStack*)">
            <summary>
            clone n segments into 1 memory block and index it with pointers 
            - the first block contains the root pointer to free later
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastPackageData.CloneDataStack(System.Int32,NSS.Blast.BlastSSMDDataStack*)">
            <summary>
            clone n segments into 1 memory block and index it with pointers 
            - the first block contains the root pointer to free later
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastPackageData.FreeData(NSS.Blast.BlastMetaDataStack*,Unity.Collections.Allocator)">
            <summary>
            free memory used by an ssmd data block
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastPackageData.FreeData(NSS.Blast.BlastSSMDDataStack*,Unity.Collections.Allocator)">
            <summary>
            free memory used by an ssmd data block
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastPackageData.Free">
            <summary>
            free any memory allocated 
            </summary>
        </member>
        <member name="T:NSS.Blast.BlastScriptPackage">
            <summary>
            BlastScriptPackage contains all data needed to use and execute scriptcode, it consists of: 
            
            - BlastPackage -> contains the native bytecode 
            - Variable information 
            - IO mapping 
            - Bursted functionpointer mapping 
            
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptPackage.Bursted">
            <summary>
            A functionpointer to burst transpiled bytecode, possible if the package was known at compile time. 
            SSMD mode will still use the bytecode package. 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptPackage.Package">
            <summary>
            the bytecode package 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptPackage.IsBurstCompiled">
            <summary>
            True if this package has also been burstcompiled and can be executed with a native function pointer 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptPackage.Inputs">
            <summary>
            defined inputs 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptPackage.Outputs">
            <summary>
            defined outputs
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptPackage.Variables">
            <summary>
            Variable information
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastScriptPackage.VariableOffsets">
            <summary>
            Offsets for variables in element count into datasegment, an elements is 4 bytes large == 1 float
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptPackage.IsAllocated">
            <summary>
            Returns true if native memory is allocated for the package 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptPackage.PackageSize">
            <summary>
            size of package data 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptPackage.PackageMode">
            <summary>
            packaging mode set by attached package data
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastScriptPackage.Flags">
            <summary>
            package flags as set by attached package
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScriptPackage.Destroy">
            <summary>
            Destroy any allocated native memory 
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScriptPackage.ToString">
            <summary>
            ToString overload for more information during debugging
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScriptPackage.GetCodeSegmentText(System.Int32,System.Boolean)">
             <summary>
             Get a string representation of the bytecode, example output: 
            
             000| push compound 1 + 2 nop push function max ^ pop 2 
             010| debug pop nop 
             
             000| 030 085 002 086 000 029 042 009 025 086 
             010| 255 253 025 000 
            
             </summary>
             <param name="width">number of columns to render</param>
             <returns>A formatted string</returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptPackage.GetDataSegmentText">
            <summary>
            Get a string representation of the datasegement
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastScriptPackage.GetPackageCodeBytesText(System.Int32,System.Boolean)">
            <summary>
            get code as 000| 000 000 000 000 
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptPackage.GetPackageDataBytesText(System.Int32,System.Boolean)">
            <summary>
            get datasegment as 000| 000 000 000 000 
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptPackage.GetPackageInfoText">
            <summary>
            return overview of package information 
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastScriptPackage.Execute(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            execute the script in the given environment with the supplied data
            </summary>
            <param name="blast">blastengine data</param>
            <param name="environment">[optional] pointer to environment data</param>
            <param name="caller">[ooptional] caller data</param>
            <returns>success if all is ok</returns>
        </member>
        <member name="T:NSS.Blast.BlastVariableMapping">
            <summary>
            description mapping a variable to an input or output
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariableMapping.Variable">
            <summary>
            the variable that is mapped 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastVariableMapping.VariableId">
            <summary>
            Id of variable 
            </summary>
        </member>
        <member name="P:NSS.Blast.BlastVariableMapping.DataType">
            <summary>
            Datatype of variable 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariableMapping.Offset">
            <summary>
            Offset of variable into datasegment, in bytes 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariableMapping.ByteSize">
            <summary>
            Bytesize of variable  
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastVariableMapping.ToString">
            <summary>
            ToString override providing a more usefull description while debugging 
            </summary>
            <returns>a formatted string</returns>
        </member>
        <member name="T:NSS.Blast.BlastVariable">
            <summary>
            Description of a variable as determined during compilation of script. It is not needed for execution
            and is thus not available through the native BlastPackageData. Native code can query metadata.
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariable.Id">
            <summary>
            the unique id of the variable as used within the script
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariable.Name">
            <summary>
            The name of the variable as it was used in the script 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariable.ReferenceCount">
            <summary>
            Number of times blast references the variable
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariable.DataType">
            <summary>
            The datatype of the variable:
            - V1: only numeric datatypes are supported
            - V2: support for ID types 
            - V3: ID64, NUMERIC64 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariable.IsConstant">
            <summary>
            is this variable constant? 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariable.IsVector">
            <summary>
            true if this is a vector of size > 1
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariable.VectorSize">
            <summary>
            vectorsize of the variable
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariable.IsInput">
            <summary>
            true if specified in inputs 
            </summary>
        </member>
        <member name="F:NSS.Blast.BlastVariable.IsOutput">
            <summary>
            true if specified in outputs 
            </summary>
        </member>
        <member name="M:NSS.Blast.BlastVariable.ToString">
            <summary>
            ToString override for a more detailed view during debugging 
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.BlastVariable.AddReference">
            <summary>
            Add a reference to this variable 
            </summary>
        </member>
        <member name="T:NSS.Blast.Register.BlastReflect">
            <summary>
            provides utilities for finding and loading compile-time blast scripts and hpc jobs
            </summary>
        </member>
        <member name="M:NSS.Blast.Register.BlastReflect.FindCompileTimeBlastScripts">
            <summary>
            get a list of scripts to compile during compilation of the unity project 
            </summary>
        </member>
        <member name="M:NSS.Blast.Register.BlastReflect.FindHPCJobs">
            <summary>
            find all hpc jobs compiled into the assemblies loaded 
            </summary>
        </member>
        <member name="T:NSS.Blast.Register.BlastScriptRegistry">
            <summary>
            Here we maintain all scripts registered, either by manually calling Register(script)
            or by finding it in the binary through reflection. 
            
            -> the registry is a static singleton
            -> this registry only stores script, not package data
            -> access is threadsafe                                 s
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NSS.Blast.Register.BlastScriptRegistry.Register(NSS.Blast.BlastScript)" -->
        <member name="M:NSS.Blast.Register.BlastScriptRegistry.Register(System.String,System.String,System.Int32)">
            <summary>
            register code with given name and id with registry
            </summary>
            <param name="code">the script code to register</param>
            <param name="name">the name to attach, should be unique and is case insensitive</param>
            <param name="id">the script id to use, 0 to generate one, should be > 0 and unique</param>
            <returns>the script id</returns>
        </member>
        <member name="M:NSS.Blast.Register.BlastScriptRegistry.All">
            <summary>
            Enumerate all registred blast scripts 
            </summary>
            <returns>a blastscript ienumerator</returns>
        </member>
        <member name="M:NSS.Blast.Register.BlastScriptRegistry.Get(System.Int32)">
            <summary>
            lookup a script with a given script id 
            </summary>
            <param name="id">integer id, must be positive</param>
            <returns>a script, or null if not found</returns>
        </member>
        <member name="M:NSS.Blast.Register.BlastScriptRegistry.Get(System.String)">
            <summary>
            perform a linear scan for a script with the given name and return iot if found. Case Insensitive
            </summary>
            <param name="name">the name to lookup</param>
            <returns>the script if found or null if nothing was found with the given name</returns>
        </member>
        <member name="M:NSS.Blast.Register.BlastScriptRegistry.Exists(System.String)">
            <summary>
            scan the registry for a script with the given name
            </summary>
            <param name="name">the case insensitive name to search for</param>
            <returns>true if found, false otherwise</returns>
        </member>
        <member name="M:NSS.Blast.Register.BlastScriptRegistry.Exists(System.Int32)">
            <summary>
            lookup the id and check if it exists
            </summary>
            <param name="id">the unique scriptid to search for</param>
            <returns>true if found, false otherwise</returns>
        </member>
        <member name="M:NSS.Blast.Register.BlastScriptRegistry.TryGetReferenceId(System.String,System.Int32@)">
            <summary>
            try to find the id of a script with a given name, performs a linear search
            </summary>
            <param name="name">the case insensitive name to lookup</param>
            <param name="reference_id">the script id</param>
            <returns>true if a script with the given name was found</returns>
        </member>
        <member name="T:NSS.Blast.CompileTimeBlastScript">
            <summary>
            any script derived from this will be compiled during compilation/design 
            
            public class BS1_compiletime : CompileTimeBlastScript
            {
                   public override string Code => @"a = a + 1;";
            }
            
            </summary>
        </member>
        <member name="T:NSS.Blast.Interpretor.BlastInterpretor">
            <summary>
            
            </summary>
        </member>
        <member name="F:NSS.Blast.Interpretor.BlastInterpretor.opt_value">
            <summary>
            >= if the opcode between opt_value and (including) opt_id then its an opcode for a constant
            </summary>
        </member>
        <member name="F:NSS.Blast.Interpretor.BlastInterpretor.opt_id">
            <summary>
            >= opt_id is starting opcode for parameters, everything until 255|ExOp is considered a datasegment index
            </summary>
        </member>
        <member name="F:NSS.Blast.Interpretor.BlastInterpretor.max_iterations">
            <summary>
            maxiumum iteration count, usefull to avoid endless loop bugs
            </summary>
        </member>
        <member name="F:NSS.Blast.Interpretor.BlastInterpretor.engine_ptr">
            <summary>
            pointer to engine data
            </summary>
        </member>
        <member name="F:NSS.Blast.Interpretor.BlastInterpretor.environment_ptr">
            <summary>
            optional pointer to environment data
            </summary>
        </member>
        <member name="F:NSS.Blast.Interpretor.BlastInterpretor.caller_ptr">
            <summary>
            optional pointer to caller information
            </summary>
        </member>
        <member name="F:NSS.Blast.Interpretor.BlastInterpretor.code">
            <summary>
            code segment pointer
            </summary>
        </member>
        <member name="F:NSS.Blast.Interpretor.BlastInterpretor.data">
            <summary>
            data segment pointer
            - for now each data element is 4 bytes long FIXED
            </summary>
        </member>
        <member name="F:NSS.Blast.Interpretor.BlastInterpretor.metadata">
            <summary>
            metadata segment pointer
            </summary>
        </member>
        <member name="F:NSS.Blast.Interpretor.BlastInterpretor.ValidationMode">
            <summary>
            if true, the script is executed in validation mode:
            - external calls just return 0's
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.Reset(NSS.Blast.BlastEngineData*,NSS.Blast.BlastPackageData)">
            <summary>
            reset code_pointer and stack_offset to their initial states 
            </summary>
            <param name="blast">pointer to blast engine data</param>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.SetPackage(NSS.Blast.BlastPackageData)">
            <summary>
            we might need to know if we need to copy back data  (or we use a dummy)
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.SetPackage(NSS.Blast.BlastPackageData,System.Byte*,System.Single*,System.Byte*,System.Int32)">
            <summary>
            set package data from package and seperate buffers 
            </summary>
            <param name="pkg">the package data</param>
            <param name="_code">code pointer</param>
            <param name="_data">datastack pointer</param>
            <param name="_metadata">metadata</param>
            <param name="initial_stack_offset"></param>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.execute(NSS.Blast.BlastEngineData*,System.IntPtr,System.IntPtr,System.Boolean)">
            <summary>
            execute bytecode
            </summary>
            <param name="blast">engine data</param>
            <param name="environment">pointer to environment data in native memory</param>
            <param name="caller">pointer to caller data in native memory</param>
            <param name="resume_state">resume state from yield or reset state to initial</param>
            <returns>success</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.Execute(NSS.Blast.BlastEngineDataPtr,System.IntPtr,System.IntPtr)">
            <summary>
            execute bytecode
            </summary>
            <param name="blast">engine data</param>
            <param name="environment">pointer to environment data in native memory</param>
            <param name="caller">pointer to caller data in native memory</param>
            <returns>exit code</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.Execute(NSS.Blast.BlastEngineDataPtr)">
            <summary>
            execute bytecode set to the interpretor 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.ResumeYield(NSS.Blast.BlastEngineDataPtr,System.IntPtr,System.IntPtr)">
            <summary>
            resume executing bytecode after yielding
            </summary>
            <param name="blast">engine data</param>
            <param name="environment">pointer to environment data in native memory</param>
            <param name="caller">pointer to caller data in native memory</param>
            <returns>exit code</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.ResumeYield(NSS.Blast.BlastEngineDataPtr)">
            <summary>
            resume executing bytecode after yielding
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.decode62(System.Byte@,System.Byte@)">
            <summary>
            decode info byte of data, 62 uses the upper 6 bits from the parametercount and the lower 2 for vectorsize, resulting in 64 parameters and size 4 vectors..
            - update to decode44? 16 params max and 16 vec size?
            </summary>
            <param name="c">input byte</param>
            <param name="vector_size"></param>
            <returns>parameter count</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.decode44(System.Byte@,System.Byte@)">
            <summary>
            decode info byte of data, 44 uses 4 bytes for each, that is 16 differen vectorsizes and param types or counts 
            </summary>
            <param name="c">input byte</param>
            <param name="vector_size"></param>
            <returns>parameter count</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.pop_f1(System.Int32@)">
            <summary>
            pop float of vectorsize 1, forced float type, verify type on debug   (equals pop_or_value)
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.pop_with_info(System.Int32@,NSS.Blast.BlastVariableDataType@,System.Byte@)">
            <summary>
            get the next value from the datasegment, stack or constant dictionary 
            </summary>
            <param name="type">datatype of element popped</param>
            <param name="vector_size">vectorsize of element popped</param>
            <returns>pointer to data castable to valuetype*</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.pop_or_value(System.Int32@)">
            <summary>
            
            1.68 ms on 100000x on the same script as the non-branch version
            
            without the branch and 2 selects its 2.23 ms on the same test
            </summary>
            <param name="code_pointer"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.GetMetaDataSize(System.Byte*@,System.Byte@)">
            <summary>
            get the size of a vector from metadata
            </summary>
            <param name="metadata">the metadata segment</param>
            <param name="offset">the variable offset</param>
            <returns>size of vector, 0 means 4..</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.GetMetaDataType(System.Byte*@,System.Byte@)">
            <summary>
            get datatype of variable from metadata
            </summary>
            <param name="metadata">the metadata segment</param>
            <param name="offset">the variable offset</param>
            <returns>the datatype</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.GetMetaData(System.Byte*@,System.Byte@,System.Byte@,NSS.Blast.BlastVariableDataType@)">
            <summary>
            get datatype and vectorsize of a variable from metadata 
            </summary>
            <param name="metadata">the metadata segment</param>
            <param name="offset">offset of variable</param>
            <param name="size">output vectorsize</param>
            <param name="type">output parametertype</param>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.yield(Unity.Mathematics.float4)">
            <summary>
            yield - stacks state
            - note that it consumes 20 bytes of stack space (on top of max used by script) to use yield
            </summary>
            <param name="f4_register"></param>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.BlastOperationIsValue(System.Byte@)">
            <summary>
            return true if op is a value: 
            - pop counts!!
            - byte value between lowest constant and extended op id  (dont allow constants in extended op id's)
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.IsMathematicalOrBooleanOperation(NSS.Blast.blast_operation)">
            <summary>
            WARNING checks if is operation, uses value op enum blast_operation.add until blast_operation.not_equals 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.IsAssignmentOperation(NSS.Blast.blast_operation)">
            <summary>
            check if the operation is one of the assignment operations: assing|assigns|assingf|assingfn|assingfen|assingv
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.IsMathematicalOperation(NSS.Blast.blast_operation)">
            <summary>
            WARNING checks if +-*/ uses value op enum!!  
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.IsBooleanOperation(NSS.Blast.blast_operation)">
            <summary>
            WARNING checks if boolean operaion, uses value op enum!! 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.handle_op(NSS.Blast.blast_operation@,System.Byte@,System.Byte@,Unity.Mathematics.float4@,Unity.Mathematics.float4@,System.Byte@)">
            <summary>
            handle an operation between 2 values in the form: <c>a = a + b;</c>
            </summary>
            <param name="op"></param>
            <param name="current"></param>
            <param name="previous"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="vector_size"></param>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.handle_op(NSS.Blast.blast_operation@,System.Single@,System.Single@)">
            <summary>
            handle operation between 2 singles of vectorsize 1, handles in the form: <c>result = a + b;</c>
            </summary>
            <param name="op">operation to take</param>
            <param name="a">operand a</param>
            <param name="b">operand b</param>
            <returns>result of operation</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.handle_op(NSS.Blast.blast_operation@,Unity.Mathematics.float2@,System.Single@)">
            <summary>
            handle operation between 2 singles of vectorsize 1, handles in the form: <c>result = a + b;</c>
            </summary>
            <param name="op">operation to take</param>
            <param name="a">operand a</param>
            <param name="b">operand b</param>
            <returns>result of operation</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.handle_op(NSS.Blast.blast_operation@,Unity.Mathematics.float3@,System.Single@)">
            <summary>
            handle operation between 2 singles of vectorsize 1, handles in the form: <c>result = a + b;</c>
            </summary>
            <param name="op">operation to take</param>
            <param name="a">operand a</param>
            <param name="b">operand b</param>
            <returns>result of operation</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.handle_op(NSS.Blast.blast_operation@,Unity.Mathematics.float4@,System.Single@)">
            <summary>
            handle operation between 2 singles of vectorsize 1, handles in the form: <c>result = a + b;</c>
            </summary>
            <param name="op">operation to take</param>
            <param name="a">operand a</param>
            <param name="b">operand b</param>
            <returns>result of operation</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.handle_op(NSS.Blast.blast_operation@,System.Single@,Unity.Mathematics.float2@)">
            <summary>
            handle operation between 2 floats of differing vectorsize, resulting vectorisize is the largest of the 2, handles in the form: <c>result = a + b;</c>
            </summary>
            <param name="op">the operation to take</param>
            <param name="a">left operand</param>
            <param name="b">right operand</param>
            <returns>returns result of operation</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.handle_op(NSS.Blast.blast_operation@,Unity.Mathematics.float2@,Unity.Mathematics.float2@)">
            <summary>
            handle operation between 2 floats of differing vectorsize, resulting vectorisize is the largest of the 2, handles in the form: <c>result = a + b;</c>
            </summary>
            <param name="op">the operation to take</param>
            <param name="a">left operand</param>
            <param name="b">right operand</param>
            <returns>returns result of operation</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.handle_op(NSS.Blast.blast_operation@,System.Single@,Unity.Mathematics.float3@)">
            <summary>
            handle operation between 2 floats of differing vectorsize, resulting vectorisize is the largest of the 2, handles in the form: <c>result = a + b;</c>
            </summary>
            <param name="op">the operation to take</param>
            <param name="a">left operand</param>
            <param name="b">right operand</param>
            <returns>returns result of operation</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.handle_op(NSS.Blast.blast_operation@,Unity.Mathematics.float3@,Unity.Mathematics.float3@)">
            <summary>
            handle operation between 2 floats of differing vectorsize, resulting vectorisize is the largest of the 2, handles in the form: <c>result = a + b;</c>
            </summary>
            <param name="op">the operation to take</param>
            <param name="a">left operand</param>
            <param name="b">right operand</param>
            <returns>returns result of operation</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.handle_op(NSS.Blast.blast_operation@,System.Single@,Unity.Mathematics.float4@)">
            <summary>
            handle operation between 2 floats of differing vectorsize, resulting vectorisize is the largest of the 2, handles in the form: <c>result = a + b;</c>
            </summary>
            <param name="op">the operation to take</param>
            <param name="a">left operand</param>
            <param name="b">right operand</param>
            <returns>returns result of operation</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.handle_op(NSS.Blast.blast_operation@,Unity.Mathematics.float4@,Unity.Mathematics.float4@)">
            <summary>
            handle operation between 2 floats of differing vectorsize, resulting vectorisize is the largest of the 2, handles in the form: <c>result = a + b;</c>
            </summary>
            <param name="op">the operation to take</param>
            <param name="a">left operand</param>
            <param name="b">right operand</param>
            <returns>returns result of operation</returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.Handle_DebugData(System.Int32,System.Byte,System.Int32,NSS.Blast.BlastVariableDataType,System.Void*)">
            <summary>
            handle command to show the given field in debug 
            </summary>
            <param name="code_pointer"></param>
            <param name="vector_size"></param>
            <param name="op_id"></param>
            <param name="datatype"></param>
            <param name="pdata"></param>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.Handle_DebugStack">
            <summary>
            printout an overview of the datasegment/stack (if shared)
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.CallExternalFunction(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
             <summary>
             call an external function pointer, pointed to by an 8|16|32 bit identifier 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_maxa_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get the maximum value of all arguments of any vectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_mina_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            return the smallest of the arguments of any vectorsize
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_csum_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            return the component sum of the arguments of any vectorsize
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_max_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get max value    [float] 
             -> all parameters should have the same vectorsize as the output
            - returns vector of same size as input
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_min_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get min value
            - all params should have the same size
            - returns vector of same size as input
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_abs_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get absolute value of input
            - single input function 
            - same output vector size as input
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_normalize_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            normalize vector 
            - single vector input, size > 1 
            - same sized vector output
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_saturate_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            saturate a vector (clamp between 0.0 and 1.0 including 0 and 1)
            - 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_ceilpow2_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_ceillog2_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_ceil_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get value rounded up (ceiling)
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_trunc_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            truncate value
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_floor_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get value rounded down (floor)
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_floorlog2_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_frac_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get fraction(s) of value (math.frac)
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_sqrt_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get roots(s) of value (math.sqrt)
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_rsqrt_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get reciprocal roots(s) of value (math.rsqrt)
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_sin_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get sinus of value 
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_cos_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get cosine
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_tan_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            calculate tangent (radians)
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_sinh_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            calculate sin-1 (radians)
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_atan_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            calculate arc tangent (radians)
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_cosh_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            calculate cos-1 (radians)
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_degrees_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            degrees from radians
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_rad_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            radians from degrees 
            - 1 parameter fixed
            - outputvectorsize == inputvectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_log2_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            calc base2 log from params
            - 1 parameter 
            - input == output vectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_log_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            calculate natural logarithm
            - 1 input
            - input == output vectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_log10_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get base 10 logarithm
            - 1 parameter 
            - input = output vectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_exp_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            raise e to given power
            - 1 parameter 
            - input = output vectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_exp10_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get base 10 exponential for parameter 
            - 1 parameter 
            - input = output vectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_pow_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            raise x to power of y 
            - always 2 parameters 
            - vectorsize in == vectorsize out
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_fmod_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            floating point modulus | rest of division
            </summary>
            <param name="code_pointer"></param>
            <param name="vector_size"></param>
            <param name="f4"></param>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_atan2_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get the full arctangengs -pi to +pi radians
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_dot_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get dot product of 2 paramaters 
            - 2 inputs
            - inputvector size = any
            - output vectorsize == 1
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_cross_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            cross product of 2 inputs 
            - 2 input parameters 
            - input vectorsize == 3
            - output vectorsize == 3
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_fma_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            fused multiply add 
            - 3 float params: m1 * m2 + a1
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_select_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            3 inputs, first 2 any type, 3rd type equal or scalar bool
            select(a, b, condition)
            - input = outputvectorsize
            - 1 output  
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_clamp_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            clamp a value between 2 others: math.clamp(a, min, max) 
            - 3 parameters - equal vectorsize or min-max == 1 and a > 1
            - input = output vectorsize 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_lerp_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            linear interpolation from a to b at step c 
            
            - 3 inputs:   3 vectors equal size or first 2 equal and last = 1 
            - only numeric input
            
            - lerp((1 2), (10 20), 0.5); 
            - lerp((1 2), (10 20), (0.5 0.1)); 
            
            returns vector size of input values 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_slerp_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            spherical linear interpolation 
            - 2 quaternion + float in
            returns float4/quaternion
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_nlerp_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            normalized linear interpolation 
            - 2 quaternion + float in
            returns float4/quaternion
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_unlerp_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            normalize between minmax -> undo lerp
            
            - 3 inputs:   3 vectors equal size or first 2 equal and last = 1 
            - only numeric input
            
            - ulerp((1 2), (10 20), 0.5); 
            - ulerp((1 2), (10 20), (0.5 0.1)); 
            
            returns vector size of input values 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_remap_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            math.remap - remap(a, b, c, d, e)   => remap e from range ab to cd
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_mula_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            multiply all inputs together
            - equal sized vectors 
            - n elements 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_adda_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            add all inputs together 
            - n elements of equal vector size 
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_any_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            a = any(a b c d), vectorsizes must all be equal, output vectorsize == input vectorsize
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_all_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            check if all operands are true ==  != 0,  works vector component wise and thus returns the same vectorsize as input
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_random_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.pop_f1_with_minus(System.Int32,System.Int32@)">
            <summary>
            pop 1 value from input stream, checks if its the minus sign, if so reads next value and negates it, otherwise returns current value 
            </summary>
            <param name="code_pointer"></param>
            <param name="cp"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.assignv(System.Int32@,System.Byte@,System.Single*@)">
            <summary>
            builds a [n] vector from [1] values 
            </summary>
            <param name="code_pointer"></param>
            <param name="vector_size"></param>
            <param name="assignee"></param>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_function_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            get the result of a function encoded in the byte code, support all fuctions in op, exop and external calls 
            although external calls should be directly called when possible
            </summary>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.get_sequence_result(System.Int32@,System.Byte@,Unity.Mathematics.float4@)">
            <summary>
            
            </summary>
            <param name="code_pointer"></param>
            <param name="vector_size"></param>
            <param name="f4_result"></param>
        </member>
        <member name="M:NSS.Blast.Interpretor.BlastInterpretor.execute(NSS.Blast.BlastEngineData*,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="blast"></param>
            <param name="environment"></param>
            <param name="caller"></param>
            <returns></returns>
        </member>
        <member name="T:NSS.Blast.SSMD.BlastSSMDInterpretor">
            <summary>
            The SSMD Interpretor 
            </summary>
        </member>
        <member name="F:NSS.Blast.SSMD.BlastSSMDInterpretor.engine_ptr">
            <summary>
            pointer to engine data
            </summary>
        </member>
        <member name="F:NSS.Blast.SSMD.BlastSSMDInterpretor.environment_ptr">
            <summary>
            optional pointer to environment data
            </summary>
        </member>
        <member name="F:NSS.Blast.SSMD.BlastSSMDInterpretor.code">
            <summary>
            code segment pointer
            </summary>
        </member>
        <member name="F:NSS.Blast.SSMD.BlastSSMDInterpretor.data">
            <summary>
            data segment pointer
            - for now each data element is 4 bytes long FIXED
            </summary>
        </member>
        <member name="F:NSS.Blast.SSMD.BlastSSMDInterpretor.metadata">
            <summary>
            metadata segment pointer
            </summary>
        </member>
        <member name="F:NSS.Blast.SSMD.BlastSSMDInterpretor.syncbits">
            <summary>
            sync buffer(s)
            </summary>
            <remarks>
            Sync buffers are composed of 1 bit for each datastream and level of nesting, every jump in ssmd mode 
            generates a new sync buffer level and these may nest until some maximum level <cref>syncbuffer_depth</cref> 
            
            </remarks>        
        </member>
        <member name="F:NSS.Blast.SSMD.BlastSSMDInterpretor.syncbuffer_depth">
            <summary>
            depth of syncbuffer 
            </summary>
        </member>
        <member name="F:NSS.Blast.SSMD.BlastSSMDInterpretor.syncbuffer_level">
            <summary>
            current maximum synclevel
            </summary>
        </member>
        <member name="F:NSS.Blast.SSMD.BlastSSMDInterpretor.ValidationMode">
            <summary>
            if true, the script is executed in validation mode:
            - external calls just return 0's
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.SetPackage(NSS.Blast.BlastPackageData@)">
            <summary>
            set ssmd package data 
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.Execute(NSS.Blast.BlastPackageData@,NSS.Blast.BlastEngineDataPtr,System.IntPtr,NSS.Blast.BlastSSMDDataStack*,System.Int32)">
            <summary>
            
            </summary>
            <param name="packagedata"></param>
            <param name="blast"></param>
            <param name="environment"></param>
            <param name="ssmddata"></param>
            <param name="ssmd_data_count"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.Execute(NSS.Blast.BlastEngineDataPtr,System.IntPtr,NSS.Blast.BlastSSMDDataStack*,System.Int32)">
            <summary>
            
            </summary>
            <param name="blast"></param>
            <param name="environment"></param>
            <param name="ssmddata"></param>
            <param name="ssmd_data_count"></param>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.push_register_f1">
            <summary>
            push register[n].x as float
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.push_data_f1(System.Int32)">
            <summary>
            push data value on stack
            </summary>
            <param name="index">index of data to lookup</param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.push_register_f2">
            <summary>
            push register[n].xy as float2 onto stack
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.push_register_f3">
            <summary>
            push register[n].xyz as float3 onto stack
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.push_register_f4">
            <summary>
            push register[n] as float4 onto stack
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.push_f1_pop_1(System.Int32@)">
            <summary>
            push a float1 value on te stack retrieved via 1 pop 
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.push_f2_pop_11(System.Int32@)">
            <summary>
            push a float2 value on te stack retrieved via 2x 1 pop 
            - each element may have a diferent origen, we need to account for that 
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.push_f3_pop_111(System.Int32@)">
            <summary>
            push an float3 value on te stack retrieved via 3x 1 pop 
            - each element may have a diferent origen, we need to account for that 
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.push_f4_pop_1111(System.Int32@)">
            <summary>
            push an float4 value on te stack retrieved via 4x 1 pop 
            - each element may have a diferent origen, we need to account for that 
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.stack_pop_f1_into(System.Single*)">
            <summary>
            pop a float1 value from the stack and copy it into destination 
            </summary>
            <param name="destination">destination f1*</param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_f1_into(System.Int32@,System.Single*)">
            <summary>
            pop a float1 value form stack|data|constant source and put it in destination 
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_f1_into_f4(System.Int32@,Unity.Mathematics.float4*)">
            <summary>
            pop an f1 from stack|data|constant and move it into f4.x
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_fx_into``1(System.Int32@,``0*)">
            <summary>
            pop a float[1|2|3|4] value form stack data or constant source and put it in destination 
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_fx_into``1(System.Int32@,System.Byte@)">
            <summary>
            pop operation [stack/constant/variabledata] and move it into dataindex 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="code_pointer"></param>
            <param name="dataindex"></param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_fx_into_indexed(System.Int32@,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            pop operation [stack/constant/variabledata] and move it into dataindex 
            - this is the indexed version of popinto 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="code_pointer"></param>
            <param name="dataindex"></param>
            <param name="offsetindex"></param>
            <param name="vector_size"></param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_stack_fx_into``1(System.Int32@,System.Byte)">
            <summary>
            pop a float from stack and assign it to dataindex inside a datasegment 
            - shouldt the compiler just directly assign the dataindex (if possible)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="code_pointer"></param>
            <param name="dataindex"></param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_f1_into_with_minus(System.Int32@,System.Byte,System.Int32@,System.Byte,System.Boolean)">
            <summary>
            pop a float and assign it to dataindex inside a datasegment, if there is a minus sign at the poplocation pop the next and keep the sign
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_f2_into_with_minus(System.Int32@,System.Byte,System.Int32@)">
            <summary>
            pop a float and assign it to dataindex inside a datasegment, if there is a minus sign at the poplocation pop the next and keep the sign
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_f3_into_with_minus(System.Int32@,System.Byte,System.Int32@)">
            <summary>
            pop a float and assign it to dataindex inside a datasegment, if there is a minus sign at the poplocation pop the next and keep the sign
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_f4_into_with_minus(System.Int32@,System.Byte,System.Int32@)">
            <summary>
            pop a float and assign it to dataindex inside a datasegment, if there is a minus sign at the poplocation pop the next and keep the sign
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.push_pop_f(System.Int32@,System.Int32@)">
            <summary>
            read codebyte, determine data location, pop data and push it on the stack
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_f1_with_op_into_f1(System.Int32@,System.Single*,System.Single*,NSS.Blast.blast_operation)">
            <summary>
            pop a float1 value from data/stack/constants and perform arithmetic op ( + - * / ) with buffer, writing the value back to m11
            </summary>
            <param name="code_pointer">current code pointer</param>
            <param name="buffer">buffer memory, may equal output</param>
            <param name="output">output memory</param>
            <param name="op">the operation to perform</param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_f2_with_op_into_f2(System.Int32@,Unity.Mathematics.float2*,Unity.Mathematics.float2*,NSS.Blast.blast_operation)">
            <summary>
            pop a float2 value from data/stack/constants and perform arithmetic op ( + - * / ) with buffer, writing the value back to output
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_f3_with_op_into_f3(System.Int32@,Unity.Mathematics.float3*,Unity.Mathematics.float3*,NSS.Blast.blast_operation)">
            <summary>
            pop a float3 value from data/stack/constants and perform arithmetic op ( + - * / ) with buffer, writing the value back to output
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_f4_with_op_into_f4(System.Int32@,Unity.Mathematics.float4*,Unity.Mathematics.float4*,NSS.Blast.blast_operation)">
            <summary>
            pop a float4 value from data/stack/constants and perform arithmetic op ( + - * / ) with buffer, writing the value back to output
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_f1_with_op_into_f4(System.Int32@,System.Single*,Unity.Mathematics.float4*,NSS.Blast.blast_operation)">
            <summary>
            pop a float1 value from data/stack/constants and perform arithmetic op ( + - * / ) with buffer, writing the value back to m11
            </summary>
            <param name="code_pointer"></param>
            <param name="buffer">temp buffer that may equal output</param>
            <param name="output">output buffer that may equal temp buffer</param>
            <param name="op">operation to handle</param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_f2_with_op_into_f4(System.Int32@,Unity.Mathematics.float2*,Unity.Mathematics.float4*,NSS.Blast.blast_operation)">
            <summary>
            pop a float2 value from data/stack/constants and perform arithmetic op ( + - * / ) with buffer, writing the value back to m11
            </summary>
            <param name="code_pointer">current codepointer</param>
            <param name="buffer">buffer that may equal output buffer</param>
            <param name="output">output buffer</param>
            <param name="op">operation to execute on value </param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.pop_f3_with_op_into_f4(System.Int32@,Unity.Mathematics.float3*,Unity.Mathematics.float4*,NSS.Blast.blast_operation)">
            <summary>
            pop a float2 value from data/stack/constants and perform arithmetic op ( + - * / ) with buffer, writing the value back to m11
            </summary>
            <param name="code_pointer"></param>
            <param name="buffer"></param>
            <param name="output"></param>
            <param name="op"></param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.set_data_from_register_f1(System.Int32@)">
            <summary>
            set a float1 data location from register location  
            </summary>
            <param name="index">data index</param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.set_data_from_register_f1_n(System.Int32@)">
            <summary>
            set a float1 data location from register location  
            </summary>
            <param name="index">data index</param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.set_from_data_f1(Unity.Mathematics.float4*,System.Void**,System.Int32)">
            <summary>
            set a dest.x buffer from data[offset]
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.set_from_data_f2(Unity.Mathematics.float4*,System.Void**,System.Int32)">
            <summary>
            set a dest.xy buffer from data[offset]
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.set_from_data_f3(Unity.Mathematics.float4*,System.Void**,System.Int32)">
            <summary>
            set a dest.xyz buffer from data[offset]
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.set_from_data_f4(Unity.Mathematics.float4*,System.Void**,System.Int32)">
            <summary>
            set a dest.xyzw buffer from data[offset]
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.set_data_from_register_f2(System.Int32@)">
            <summary>
            set a float2 data location from register location  
            </summary>
            <param name="index">data index</param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.set_data_from_register_f2_n(System.Int32@)">
            <summary>
            set a float2 data location from register location  
            </summary>
            <param name="index">data index</param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.set_data_from_register_f3(System.Int32@)">
            <summary>
            set a float3 data location from register location  
            </summary>
            <param name="index">data index</param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.set_data_from_register_f3_n(System.Int32@)">
            <summary>
            set a float3 data location from register location  
            </summary>
            <param name="index">data index</param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.set_data_from_register_f4(System.Int32@)">
            <summary>
            set a float4 data location from register location  
            </summary>
            <param name="index">data index</param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.set_data_from_register_f4_n(System.Int32@)">
            <summary>
            set a float4 data location from register location  
            </summary>
            <param name="index">data index</param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.set_register_from_data_f1(System.Single*)">
            <summary>
            set register[n].x from data 
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.set_register_from_data_f4(Unity.Mathematics.float4*)">
            <summary>
            set register[n].xyzw from data 
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.handle_op_f1_f1(NSS.Blast.blast_operation@,Unity.Mathematics.float4*,Unity.Mathematics.float4*,System.Byte@)">
            <summary>
            handle operation a.x and b.x
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.get_cross_result(System.Void*,System.Int32@,System.Byte@,Unity.Mathematics.float4*)">
            <summary>
            only accepts size 3 vectors 
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.get_dot_result(System.Void*,System.Int32@,System.Byte@,Unity.Mathematics.float4*)">
            <summary>
            result vector size == 1 in all cases
            </summary>
            <param name="temp"></param>
            <param name="code_pointer"></param>
            <param name="vector_size"></param>
            <param name="register"></param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.get_select_result(System.Void*,System.Int32@,System.Byte@,Unity.Mathematics.float4*)">
            <summary>
            select first input on a false condition, select the second on a true condition that is put in parameter 3
            </summary>
            <remarks>
            3 inputs, first 2 any type, 3rd type equal or scalar bool
            
            c[x] = select(a[x], b[x], condition[1/x])
            
            - input = outputvectorsize
            - 1 output  
            
            Assembly for scalar constants<c>a = select(1, 2, 1) => setf a select 1 2 1 nop</c>
            
            Assembly sample with vectors: <c>a = select((1 1), (2 2), 1) => setf a select 1 pop pop nop</c>
            </remarks>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.get_clamp_result(System.Void*,System.Int32@,System.Byte@,Unity.Mathematics.float4*)">
            <summary>
            clamp value between operands
            </summary>
            <remarks>
            first min then max => saves 1 memory buffer doing this in sequence (math lib will also do min(max( so this should be equal in performance but turned upside down in flow
            <code>
            
            a = clamp(a, min, max); 
            
            </code>
            </remarks>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.get_lerp_result(System.Void*,System.Int32@,System.Byte@,Unity.Mathematics.float4*)">
            <summary>
            lerp value from min to max 
            </summary>
            <remarks>
            
            a = lerp(min, max, s); 
            
            TODO :     for all 3 input functions:   we should test stackallocs if they are conditional or not
            - if they are always allocated move every case with stackalloc into its own function ? code explosin without templates/generics
             
            </remarks>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.get_unlerp_result(System.Void*,System.Int32@,System.Byte@,Unity.Mathematics.float4*)">
            <summary>
            undo lerp 
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.get_slerp_result(System.Void*,System.Int32@,System.Byte@,Unity.Mathematics.float4*)">
            <summary>
            sperical lerp on quaternions 
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.get_nlerp_result(System.Void*,System.Int32@,System.Byte@,Unity.Mathematics.float4*)">
            <summary>
            normalized lerp on quaternions
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.get_mina_result(System.Void*,System.Int32@,System.Byte@,Unity.Mathematics.float4*)">
            <summary>
            get the minimal component from all arguments of any vectorsize
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.get_maxa_result(System.Void*,System.Int32@,System.Byte@,Unity.Mathematics.float4*)">
            <summary>
            get the max component from all arguments of any vectorsize
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.get_csum_result(System.Void*,System.Int32@,System.Byte@,Unity.Mathematics.float4*)">
            <summary>
            get component sum of all arguments of any vectorsize
            </summary>
            <param name="temp"></param>
            <param name="code_pointer"></param>
            <param name="vector_size"></param>
            <param name="f4"></param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.get_op_a_result(System.Void*,System.Int32@,System.Byte@,Unity.Mathematics.float4*@,NSS.Blast.blast_operation)">
            <summary>
            handle a sequence of operations
            - mula e62 p1 p2 .. pn
            - every parameter must be of same vector size 
            - future language versions might allow multiple vectorsizes in mula 
            </summary>
            <param name="temp">temp scratch data</param>
            <param name="code_pointer">current codepointer</param>
            <param name="vector_size">output vectorsize</param>
            <param name="f4">output data vector</param>
            <param name="operation">operation to take on the vectors</param>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.get_fma_result(System.Void*,System.Int32@,System.Byte@,Unity.Mathematics.float4*@)">
            <summary>
            fused multiply add 
            - always 3 params, input vector size == output vectorsize
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.GetFunctionResult(System.Void*,System.Int32@,System.Byte@,Unity.Mathematics.float4*@,System.Boolean)">
            <summary>
            get the result of a function encoded in the byte code, support all fuctions in op, exop and external calls 
            although external calls should be directly called when possible
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.GetSequenceResult(System.Void*,System.Int32@,System.Byte@)">
            <summary>
            process a sequence of operations into a new register value 
            </summary>        
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.assigns(System.Int32@,System.Byte@,System.Void*)">
            <summary>
            assign single value 
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.assign(System.Int32@,System.Byte@,System.Void*)">
            <summary>
            assign result of a sequence 
            </summary>
        </member>
        <member name="M:NSS.Blast.SSMD.BlastSSMDInterpretor.Execute(System.Byte*,System.Byte**,System.Int32,Unity.Mathematics.float4*)">
            <summary>
            main interpretor loop 
            </summary>
            <param name="syncbuffer"></param>
            <param name="datastack"></param>
            <param name="ssmd_data_count">should be divisable by 8</param>
            <param name="f4_register"></param>
            <returns></returns>
        </member>
    </members>
</doc>
